
INJECTIONS

# include       "tilengine.hpp"
# include       "blkbuffer.hpp"
# include       "stacks.hpp"

using namespace Ice9::Memory;


static bool no_ok;
static const char MESSAGE_SILENT[]  = "";
static const char MESSAGE_START[]   = "Froth " STR(__WORDSIZE) "-bit TIL\n";
static const char MESSAGE_RESTART[] = "RESTART";
static const char MESSAGE_SIGINT[]  = "\nINTERRUPTED";
static const char MESSAGE_OK[]      = " OK";
static const char MESSAGE_QUE[]     = " ?";
static const char MESSAGE_DIV0[]    = " Divide by zero";
static const char MESSAGE_USTACK[]  = " Data Stack underflow";
static const char MESSAGE_OSTACK[]  = " Data Stack overflow";
static const char MESSAGE_FUSTACK[] = " Float Stack underflow";
static const char MESSAGE_FOSTACK[] = " Float Stack overflow";
static const char MESSAGE_OUSTACK[] = " Object Stack underflow";
static const char MESSAGE_OOSTACK[] = " Object Stack overflow";
static const char MESSAGE_BADCHAR[] = " Bad character literal";
static const char MESSAGE_BADSTR[]  = " Bad string literal";

# define    SPEWING(msg)    { WA = CellPtr(msg); goto $PATCH; }

// static THREAD_VAR RefCount::Allocator alloc;

THREAD_VAR BlockBuffer BlockBuffer::bufs[NUM_BLK_BUFFERS];
THREAD_VAR BlockBuffer::Ptr BlockBuffer::bbpLRU, BlockBuffer::bbpMRU;
THREAD_VAR BlockBuffer::Ptr BlockBuffer::bbpCurrent;
THREAD_VAR sCell BlockBuffer::fd;

// record the tty-ness of stdin and stdout fd's. Do we care about stderr? not yet!!
static bool isatty0, isatty1;

// several of these are not made thread_local since only one thread can use readline()
static rwlock_t rwlLB;
static bool LBprep = 0;
static THREAD_VAR bool LBownsRL = 0;
static char LBhistFile[PATH_MAX];
static sigjmp_buf sjbReadline;      // only one thread claims the readline system, so this doesn't have to be thread-local
static THREAD_VAR pthread_attr_t pthr_attr;
static THREAD_VAR pthread_mutexattr_t pthr_mattr;
static THREAD_VAR char LineBuffer[SIZE_LINEBUF + 1];

static THREAD_VAR char PadBuffer[SIZE_PADBUF + 1];
static THREAD_VAR CountedString<SIZE_PNOBUF + 1> PnoBuffer;         // Pictured Numeric Output buffer also used by Word
static THREAD_VAR Cell Precision = 6;
static THREAD_VAR unsigned int seedp = 1;

static THREAD_VAR Stack2<SIZE_DATA_STACK, Cell, Cell2> SP;          // data stack for Cell and Cell2
static THREAD_VAR Stack<SIZE_RETURN_STACK, CellPtrPtr> RS;          // Return stack
static THREAD_VAR Stack<SIZE_FLOAT_STACK, FloatLD> FP;              // data stack for long doubles
static THREAD_VAR Stack<SIZE_OBJECT_STACK, OP> OS;
static THREAD_VAR CellPtrPtr *localBase;

////////////////////////////////////////////////////////////////////////////////////////////////////
// IP  address of next Instruction in the threaded list of current secondary
// WA  Cell Address of the current keyword or address of the first code body location in the current keyword
// CA  Code Address register (actually a goto-offset from &&$COLON)
// PC  Processor Program Counter register (ie executable C code jump target)

static THREAD_VAR CellPtrPtr IP;
static THREAD_VAR CellPtr WA;
static THREAD_VAR Cell CA;
static THREAD_VAR Char *LBsrc;
static THREAD_VAR Cell LBofs, LBlen;         // working offset and length of LineBuffer

static THREAD_VAR Cell return_code = 0;
static THREAD_VAR Cell exception_frame = 0;
static THREAD_VAR Byte TRAP = 0, inReadline = 0;
static THREAD_VAR Char cTmp, cTmp2;
static THREAD_VAR CharPtr cpTmp, cpTmp2;

static THREAD_VAR Float32 f32Tmp;
static THREAD_VAR Float64 f64Tmp;
static THREAD_VAR FloatLD fLDTmp;

static THREAD_VAR FILE *fdTmp;

static THREAD_VAR OP opTmp, opTmp2;
static THREAD_VAR OP *oppTmp, *oppTmp2;

static THREAD_VAR Cell clTmp, clTmp2;
static THREAD_VAR Cell2 cl2Tmp;
static THREAD_VAR CellPtr clpTmp, clpTmp2;
static THREAD_VAR Cell2Ptr cl2pTmp;

static THREAD_VAR sCell slTmp, slTmp2;
static THREAD_VAR sCell2 sl2Tmp, sl2Tmp2;
static THREAD_VAR sCellPtr slpTmp;
static THREAD_VAR sCell2Ptr sl2pTmp;

static THREAD_VAR pthread_t thrTmp;
static THREAD_VAR Cell *threadTransfer;

static THREAD_VAR Cell Blk;
static THREAD_VAR FILE *SourceID;
static THREAD_VAR Byte Base = 0;
static THREAD_VAR Char FOpenName[PATH_MAX];
static THREAD_VAR struct stat stat_buf;

static THREAD_VAR struct LocalsDef locals[MAX_LOCALS];
static THREAD_VAR int nLocals = 0;


static void cleanLocals() {
    if(nLocals > 0) {
        while(nLocals > 0)
            free(locals[--nLocals].cp);
        memset(locals, sizeof(locals), 0);
    }
}   /* cleanLocals */


////////////////////////////////////////////////////////////////////////////////////////////////
// Dictionary and vocabulary beasties
//
static THREAD_VAR CellPtrPtr vocpContext = NULL;      // old-school search list - TO BE REMOVED
static THREAD_VAR CellPtrPtr vocpCurrent = NULL;      // where definitions go
static THREAD_VAR Cell LeaveLink = 0;
static THREAD_VAR Byte State, Immediate, Quitting;

// none below are thread-local because the dictionary array cannot be. - well, it could be,
// but the house-keeping to initialize it would suck, and why would each thread need it's own
// dictionary any way?
// NOTE ALSO: the Dictionary is static non-thread_var but it must be inside engine() due to
// storing calculated GOTO targets.
//
static rwlock_t rwlDict;
static CellPtr DP = NULL;


// TODO: proper implementation of the Search Order Wordset will probably mean these are not needed.
// However, the way the dictionary(s) are built, these may still help the C code generator.
// Time will tell...
//
static CellPtr voc_root = NULL;
static CellPtr voc_forth = NULL;
static CellPtr voc_op = NULL;
static CellPtr voc_thread = NULL;
static CellPtr voc_mutex = NULL;
static CellPtr voc_condvar = NULL;
//
// Words and objects that may need to be destroyed as old-fashioned when Search Order Wordset is working:
//   vocpContext context current

// The search-order is also not thread-local, although it would be much simpler to arrange that.
// The real question is, would it be useful?
//
static CellPtrPtr searchOrder[SIZE_SEARCH_ORDER];     // first entry is searched last. This is a stack.
static Cell nSearchOrder;


// now, something to record which lock we ask for so's we don't stupidly try to lock twice.
// NOTE ALSO: if a read lock is acquired, later attempts to get a write lock are A SERIOUS FAULT requiring a screaming abort.
// so get it right... write-lock early and never inside something that might be called from a pre-existing read-lock flow.
//
static THREAD_VAR rwl_lock_e rwlOwned = RWL_NOTHING;        // lies! this is thread local!
static THREAD_VAR short rwlDepth = 0;                       // lies! this is thread local!


void Catcher(int sig) {
    static char mesg[100];
    if(sig == SIGINT) {
        if(inReadline)
            siglongjmp(sjbReadline, 1);
        else
            TRAP = SIGINT;
    }
    else {
        sprintf(mesg, "\nCAUGHT %d: %s\n", sig, strsignal(sig));
        write(2, mesg, strlen(mesg));
        exit(1);
    }
}   /* Catcher */


void setupCatcher() {
    struct sigaction act;
    act.sa_handler = Catcher;
    sigemptyset(&act.sa_mask);    // TODO: mask out everything??
    act.sa_flags = 0;

    sigaction(SIGHUP, &act, NULL);
    sigaction(SIGINT, &act, NULL);
    sigaction(SIGQUIT, &act, NULL);
    sigaction(SIGILL, &act, NULL);
    sigaction(SIGABRT, &act, NULL);
    sigaction(SIGFPE, &act, NULL);
    sigaction(SIGSEGV, &act, NULL);
    sigaction(SIGTERM, &act, NULL);
    sigaction(SIGBUS, &act, NULL);
    sigaction(SIGSYS, &act, NULL);
}   /* setupCatcher */


// tools to acquire and release possibly nested locks.
// NOTE: a read lock cannot be promoted to a write lock
// but a read-lock can be asked for on top of a write lock (will be counted and ignored)
//
static void upDictLock(rwl_lock_e rwle) {
    assert(rwlOwned != RWL_READ || rwlOwned == rwle);

    if(rwlOwned == RWL_NOTHING) {
        if((rwlOwned = rwle) == RWL_READ)
            rwlDict.readLock();
        else
            rwlDict.writeLock();
    }

    ++rwlDepth;
}   /* upDictLock */


static void dnDictLock() {
    assert(rwlDepth > 0);

    if(--rwlDepth == 0) {
        if(rwlOwned == RWL_READ)
            rwlDict.readUnlock();
        else
            rwlDict.writeUnlock();
        rwlOwned == RWL_NOTHING;
    }
}   /* dnDictLock */


static Cell oneChar() {
    Char ch;
    Cell w;
    sCell i;

    if(LBofs >= LBlen || ! LBsrc[LBofs])
        return Cell(-1);    // if you know what I mean .... let's stick to Unicode at the biggest eh?

    if((w = LBsrc[LBofs++]) != '\\')
        return w;

    if(LBofs >= LBlen || ! LBsrc[LBofs])
        return '\\';        // best we can do - Or Is It?

    switch(w = LBsrc[LBofs++]) {
      case 'a': w = '\07';  break;
      case 'b': w = '\b';   break;
      case 'e': w = '\033'; break;
      case 'f': w = '\f';   break;
      case 'n': w = '\n';   break;
      case 'r': w = '\r';   break;
      case 't': w = '\t';   break;
      case 'v': w = '\v';   break;

      case 'c':
        // control-character
        if(LBofs >= LBlen || ! LBsrc[LBofs])
            return 'c';     // sheesh

        w = 0x1F & LBsrc[LBofs++];
        break;

      case 'x':
        // \xAB
        // later: \x{XXXXXXXX}
        if(! isxdigit(LBsrc[LBofs]))
            return 'x';     // sheesh
        ch = LBsrc[LBofs++];
        if(ch >= 'a')
            w = ch - 'a' + 10;
        else if(ch >= 'A')
            w = ch - 'A' + 10;
        else
            w = ch - '0';

        ch = LBsrc[LBofs];
        if(isxdigit(ch)) {
            ++LBofs;
            w *= 16;
            if(ch >= 'a')
                w += ch - 'a' + 10;
            else if(ch >= 'A')
                w += ch - 'A' + 10;
            else
                w += ch - '0';
        }
        break;

   // case 'N':     // named unicode character - LATER!!

      default:
        if('0' <= w && w <= '7') {
            // octal
            w -= '0';
            if('0' <= LBsrc[LBofs] && LBsrc[LBofs] <= '7') {
                w *= 8;
                w += LBsrc[LBofs++] - '0';
            }
            if('0' <= LBsrc[LBofs] && LBsrc[LBofs] <= '7') {
                w *= 8;
                w += LBsrc[LBofs++] - '0';
            }
        }
        break;
    }

    return w;
}   /* oneChar */


static void skip_string() {
    // skip a string stored as U ccc in the dictionary, including any alignment padding
    IP = CellPtrPtr(Cell(CharPtr(IP + 1) + Cell(*IP) + sizeof(Cell) - 1) & ~ (sizeof(Cell) - 1));
}   /* skip_string */


static void prep_ior(sCell val) {
    if(val == -1)
        SP.push(errno);
    else
        SP.push(0);
}


# define NUM_REGIONS 500
THREAD_VAR MemRegion regions[NUM_REGIONS];
THREAD_VAR int nRegions = 0;

int cmpRegion(const void *l, const void *r) {
    MemRegion::Ptr mrLeft  = MemRegion::Ptr(l);
    MemRegion::Ptr mrRight = MemRegion::Ptr(r);

    if(mrLeft->cpStart < mrRight->cpStart) return -1;
    if(mrLeft->cpStart > mrRight->cpStart) return  1;
    if(mrLeft->cpEnd < mrRight->cpEnd) return -1;
    if(mrLeft->cpEnd > mrRight->cpEnd) return  1;
    return 0;
}   /* cmpRegion */


void registerRegion(const char *cpName, const char *cpStart, sCell size, CellPtr handler = NULL) {
    if(size < 0) {
        printf("Attempt to register region %s with size %d!\n", cpName, size);
        exit(99);
    }

    if(nRegions >= NUM_REGIONS) {
        fprintf(stderr, "Cannot register any more regions: %s\n", cpName);
        return;
    }

    regions[nRegions].cpName = cpName;
    regions[nRegions].cpStart = cpStart;
    regions[nRegions].cpEnd = cpStart + size - 1;
    regions[nRegions].handler = handler;
    ++nRegions;

    // always keep the regions sorted in code-address order
    qsort(regions, nRegions, sizeof(MemRegion), &cmpRegion);
}   /* registerRegion */


int matchRegion(const void *l, const void *r) {
    CharPtr cpLeft = CharPtr(l);
    MemRegion::Ptr mrRight = MemRegion::Ptr(r);

    if(cpLeft < mrRight->cpStart) return -1;
    if(cpLeft > mrRight->cpEnd)   return  1;
    return 0;
}


static CellPtr nameOfXT(SpecialWordNames specs[], CellPtr clpDict, CellPtr clp) {
    if(clpDict > CellPtr(*clp) || CellPtr(*clp) >= DP)
        return NULL;

    for(int i = 0; specs[i].length; ++i)
        if(specs[i].clWordAddr == *clpTmp)
            return &specs[i].length;

# ifdef OPT_S
    for(clp = CellPtr(*clp); clp >= clpDict + 2; --clp)
        if(clp[-1] == DICT_MAGIC && clp[-2] == DICT_MAGIC && clp[-3] == DICT_MAGIC)
            return clp;
# else
    int n = 0;
    for(clp = CellPtr(*clp); n < 64 && clp >= clpDict + 2; --clp, ++n)
        if(clp[-1] == DICT_MAGIC && clp[-2] == DICT_MAGIC && clp[-3] == DICT_MAGIC)
            return clp;
# endif

    return NULL;
}    /* nameOfXT */


static void init_readline() {
    // using_history();
    if(! LBprep) {
        rwlLB.writeLock();

        // one thread only allowed to use readline
        // TODO: check out threaded usage
        if(! LBprep) {
            LBprep = true;

            if(isatty0) {
                LBownsRL = true;
                rl_bind_key('\t', rl_insert);

                // getuid or geteuid?
                struct passwd *pwp = getpwuid(getuid());
                if(pwp && pwp->pw_dir) {
                    strncpy(LBhistFile, pwp->pw_dir, PATH_MAX - 1);
                    // 20 - a generous allowance for the final file addend
                    LBhistFile[PATH_MAX - 20 - 1] = '\0';
                    strcat(LBhistFile, "/.froth_history");

                    int status = read_history(LBhistFile);
                    if(status && errno == ENOENT) {
                        int fd = creat(LBhistFile, 0666);
                        if(fd == -1) {
                            perror("cannot create history file");
                            LBhistFile[0] = 0;
                        }
                        else {
                            close(fd);
                        }
                    }
                }
            }
        }

        rwlLB.writeUnlock();
    }
}   /* init_readline */


bool setThreadTransfer(Cell n) {
    if(n == 0) {
        free(threadTransfer);
        threadTransfer = NULL;      // making sure
        return true;
    }

    threadTransfer = CellPtr(calloc(n + 1, sizeof(Cell)));      // +1 for n

    if(! threadTransfer)
        return false;

    threadTransfer[0] = n;
    Cell i = 1;
    while(n-- > 0)
        threadTransfer[i++] = SP.pop();
    return true;
}   /* setThreadTransfer */


void getThreadTransfer() {
    if(threadTransfer) {
        Cell i = threadTransfer[0];
        while(i > 0)
            SP.push(threadTransfer[i--]);
        free(threadTransfer);
        threadTransfer = NULL;
    }
}   /* getThreadTransfer */


static void _engine(Cell new_thread) {
    static THREAD_VAR time_t tmt;
    static THREAD_VAR struct tm tms;

    static Cell Dictionary[SIZE_DICTIONARY] = {
        DICTIONARY
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////

    static SpecialWordNames specs[] = {
        { Cell(CODE_ADDRESS($$literal)),     9, " *literal" },
        { Cell(CODE_ADDRESS($$do)),          4, " *do"      },
        { Cell(CODE_ADDRESS($$loop)),        6, " *loop"    },
        { Cell(CODE_ADDRESS($$_add_loop)),   7, " *+loop"   },
        { Cell(CODE_ADDRESS($$jmp)),         5, " *jmp"     },
        { Cell(CODE_ADDRESS($$jmpnz)),       7, " *jmpnz"   },
        { Cell(CODE_ADDRESS($$jmpz)),        6, " *jmpz"    },
        { Cell(CODE_ADDRESS($$question_do)), 5, " *?do"     },
        { Cell(CODE_ADDRESS($$leave)),       7, " *leave"   },
        { 0, 0, 0 },
    };

    // KEEP in sorted order! will probably end up using bsearch
    // and REMEMBER: -1 is the standard TRUE, don't use 1 (even though it would work as such...)
    static Environment envir[] {
        {  7, "#LOCALS",            MAX_LOCALS          },      // n       maximum number of local variables in a definition
        { 15, "/COUNTED-STRING",    MAX_SCELL           },      // n       maximum size of a counted string, in characters
        {  5, "/HOLD",              SIZE_PNOBUF         },      // n       size of the pictured numeric output string buffer, in characters
        {  4, "/PAD",               SIZE_PADBUF         },      // n       size of the scratch area pointed to by PAD, in characters
        { 17, "ADDRESS-UNIT-BITS",  __WORDSIZE          },      // n       size of one address unit, in bits
        {  5, "BLOCK",              0                   },      // flag    block word set present
        {  9, "BLOCK-EXT",          0                   },      // flag    block extensions word set present
        {  4, "CORE",               0                   },      // flag    true if complete core word set present (i.e., not a subset as defined in 5.1.1)
        {  8, "CORE-EXT",           0                   },      // flag    true if core extensions word set present
        {  6, "DOUBLE",             0                   },      // flag    double-number word set present
        { 10, "DOUBLE-EXT",         0                   },      // flag    double-number extensions word set present
        {  9, "EXCEPTION",          TRUE                },      // flag    exception word set present
        { 13, "EXCEPTION-EXT",      0                   },      // flag    exception extensions word set present
        {  8, "FACILITY",           0                   },      // flag    facility word set present
        { 12, "FACILITY-EXT",       0                   },      // flag    facility extensions word set present
        {  4, "FILE",               TRUE                },      // flag    file word set present
        {  8, "FILE-EXT",           TRUE                },      // flag    file extensions word set present
        {  8, "FLOATING",           0                   },      // flag    floating-point word set present
        { 12, "FLOATING-EXT",       0                   },      // flag    floating-point extensions word set present
        { 14, "FLOATING-STACK",     SIZE_FLOAT_STACK    },      // n       If n = zero, FP are kept on data stack; otherwise max depth of FP stack.
        {  7, "FLOORED",            TRUE                },      // flag    true if floored division is the default
        {  6, "LOCALS",             TRUE                },      // flag    locals word set present
        { 10, "LOCALS-EXT",         TRUE                },      // flag    locals extensions word set present
        {  8, "MAX-CHAR",           255                 },      // u       maximum value of any character in the implementation-defined character set
        {  5, "MAX-D", 0, GOTO_ADR(dwc_$$env_max_d)     },      // d       largest usable signed double number
        {  9, "MAX-FLOAT", 0, GOTO_ADR(dwc_$$env_max_float) },  // r       largest usable floating-point number
        {  5, "MAX-N",              MAX_SCELL           },      // n       largest usable signed integer
        {  5, "MAX-U",              MAX_CELL            },      // u       largest usable unsigned integer
        {  6, "MAX-UD", 0, GOTO_ADR(dwc_$$env_max_ud)   },      // ud      largest usable unsigned double number
        { 12, "MEMORY-ALLOC",       TRUE                },      // flag    memory-allocation word set present
        { 16, "MEMORY-ALLOC-EXT",   TRUE                },      // flag    memory-allocation extensions word set present
        { 18, "RETURN-STACK-CELLS", SIZE_RETURN_STACK   },      // n       maximum size of the return stack, in cells
        { 12, "SEARCH-ORDER",       0                   },      // flag    search-order word set present
        { 16, "SEARCH-ORDER-EXT",   0                   },      // flag    search-order extensions word set present
        { 11, "STACK-CELLS",        SIZE_DATA_STACK     },      // n       maximum size of the data stack, in cells
        {  6, "STRING",             TRUE                },      // flag    string word set present
        { 10, "STRING-EXT",         TRUE                },      // flag    string extensions word set present
        {  5, "TOOLS",              0                   },      // flag    programming-tools word set present
        {  9, "TOOLS-EXT",          0                   },      // flag    programming-tools extensions word set present
        {  9, "WORDLISTS",          SIZE_SEARCH_ORDER   },      // n       maximum number of word lists usable in the search order

        { 0, 0, 0 },
    };

$$HEAD:
    // first pass through initializes the dictionary-related variables, doesn't require a lock
    if(DP != NULL)
        // otherwise, normal engine preparation for a thread requires a read-lock so it can capture addresses
        upDictLock(RWL_READ);
    goto $PREP_CORE;

$COLON:
    // must have intervening code: need (&&$COLON - &&$$HEAD) to be non-zero
    // TODO: make the goto offsets relative to engine itself? That way, other
    // subs can assign and even call them (fairly) reliably if they are stored
    // as offsets by something wot knows.
    // assert(GOTO_ADR($COLON));    // prove it has an offset!
    RS.push(IP);
    IP = CellPtrPtr(WA);
    goto $NEXT;


    // all environment? handlers must also push true - sorry, it's just a bit easier that way
    PRIMARY -noheader $$env_max_ud
        SP.push2(MAX_2CELL);
        SP.push(TRUE);
    END


    PRIMARY -noheader $$env_max_d
        SP.push2(MAX_2SCELL);
        SP.push(TRUE);
    END


    PRIMARY -noheader $$env_max_float
        FP.push(MAX_FLOATLD);
        SP.push(TRUE);
    END


    // secondaries can control dictionary locks using these wrappers
    PRIMARY -noheader rd_dict_lock
        upDictLock(RWL_READ);
    END


    PRIMARY -noheader wr_dict_lock
        upDictLock(RWL_WRITE);
    END


    PRIMARY -noheader dn_dict_lock
        dnDictLock();
    END


    PRIMARY -noheader $$lscolon
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        RS.ptr() = localBase;
        localBase = (CellPtrPtr *) RS.pop();
        goto dwc_$$scolon;
    END


    PRIMARY -noheader $$scolon
        IP = RS.pop();
 $NEXT: if(TRAP) goto $TRAP;
        WA = CellPtr(*IP++);
  $RUN: CA = *WA++;
        goto *VoidPtr(Cell(&&$$HEAD) + CA);
     // goto *VoidPtr(CA);

 $TRAP: // TODO: handle interrupts, faults, exceptions, thread switches etc
        if(TRAP == SIGINT)
            WA = CellPtr(MESSAGE_SIGINT);
        else
            WA = CellPtr(MESSAGE_RESTART);
        TRAP = 0;
        goto $PATCH;
        next;
    END



    //////////////////////////////////////////////////////////////////////
    // Search Order words

    // Search-Order words 16.6 NOTHING IMPLEMENTED
    // ------------------
    // 1.1180      DEFINITIONS                 ( -- )
    //
    // 1.1550      FIND                        ( c-addr -- c-addr 0  |  xt 1  |  xt -1 )
    // Extend the semantics of 6.1.1550 FIND
    //
    // 1.1595      FORTH-WORDLIST              ( -- wid )
    // 1.1643      GET-CURRENT                 ( -- wid )
    // 1.1647      GET-ORDER                   ( -- widn ... wid1 n )
    // 1.2192      SEARCH-WORDLIST             ( c-addr u wid -- 0 | xt 1 | xt -1 )
    // 1.2195      SET-CURRENT                 ( wid -- )
    // 1.2197      SET-ORDER                   ( widn ... wid1 n -- )
    // 1.2460      WORDLIST                    ( -- wid )
    // 2.0715      ALSO                        ( -- )
    // 2.1590      FORTH                       ( -- )
    // 2.1965      ONLY                        ( -- )
    // 2.1985      ORDER                       ( -- )
    // 2.2037      PREVIOUS                    ( -- )
    //             ROOT ???
    // -- 16.6 NOTHING IMPLEMENTED


    ANSI PRIMARY definitions                            ( -- )
        // Make the compilation word list the same as the ﬁrst word list in the search order.
        // Speciﬁes that the names of subsequent deﬁnitions will be placed in the compilation word list.
        // Subsequent changes in the search order will not affect the compilation word list.

        vocpCurrent = searchOrder[nSearchOrder - 1];
        // TODO: EXPLODE IF nSearchOrder == 0
        // TODO: does it consume the last entry????
    END


=work-in-progress
    16.6.1.1550 FIND
    Extend the semantics of 6.1.1550 FIND to be:
        ( c-addr -- c-addr 0 | xt 1 | xt -1 )

    Find the deﬁnition named in the counted string at c-addr. If the deﬁnition is not found after
    searching all the word lists in the search order, return c-addr and zero. If the deﬁnition is
    found, return xt. If the deﬁnition is immediate, also return one (1); otherwise also return
    minus-one (-1). For a given string, the values returned by FIND while compiling may differ
    from those returned while not compiling.

    See: 3.4.2 Finding deﬁnition names
         6.1.0070 ’
         6.1.1550 FIND
         6.1.2033 POSTPONE
         6.1.2510 [’]
=end


    ANSI PRIMARY $forth_wordlist "forth-wordlist"       ( -- wid )
        // Return wid, the identiﬁer of the word list that includes all standard words provided by
        // the implementation. This word list is initially the compilation word list and is part
        // of the initial search order.

        SP.clppPush(&voc_forth);
    END


    ANSI PRIMARY $get_current "get-current"             ( -- wid )
        // Return wid, the identiﬁer of the compilation word list.
        SP.clppPush(vocpCurrent);
    END


    ANSI PRIMARY $get_order "get-order"                 ( -- widn . . . wid1 n )
        // Returns the number of word lists n in the search order and the word list identiﬁers

        for(clTmp = 0; clTmp < nSearchOrder; ++clTmp)
            SP.clppPush(searchOrder[clTmp]);
        SP.push(nSearchOrder);
    END


=work-in-progress
    16.6.1.2192 SEARCH-WORDLIST
        ( c-addr u wid -- 0 | xt 1 | xt -1 )

    Find the deﬁnition identiﬁed by the string c-addr u in the word list identiﬁed by wid.
    If the deﬁnition is not found, return zero. If the deﬁnition is found, return its execution
    token xt and one (1) if the deﬁnition is immediate, minus-one (-1) otherwise.

    See: A.16.6.1.2192 SEARCH-WORDLIST
=end


    ANSI PRIMARY $set_current "set-current"             ( wid -- )
        // Set the compilation word list to the word list identiﬁed by wid.
        vocpCurrent = SP.clppPop();
    END


    ANSI PRIMARY $set_order "set-order"                 ( widn . . . wid1 n -- )
        // Set the search order to the word lists identiﬁed by widn . . . wid1
        // TODO: EXPLODE IF SP.top() > SIZE_SEARCH_ORDER
        nSearchOrder = SP.pop();
        for(clTmp = nSearchOrder; clTmp > 0; --clTmp)
            searchOrder[clTmp - 1] = SP.clppPop();
    END


=work-in-progress
    16.6.1.2460 WORDLIST
        ( -- wid )

    Create a new empty word list, returning its word list identiﬁer wid. The new word list
    may be returned from a pool of preallocated word lists or may be dynamically allocated
    in data space. A system shall allow the creation of at least 8 new word lists in addition
    to any provided as part of the system.
=end



    ANSI PRIMARY also                                   ( -- )
        // duplicate top of searchOrder
        clTmp = Cell(searchOrder[nSearchOrder - 1]);
        // TODO: EXPLODE IF nSearchOrder == SIZE_SEARCH_ORDER
        searchOrder[nSearchOrder++] = CellPtrPtr(clpTmp);
    END


    ANSI PRIMARY forth                                  ( -- )
        // replace top of search order with FORTH-WORDLIST
        // TODO: EXPLODE IF nSearchOrder == 0
        searchOrder[nSearchOrder - 1] = &voc_forth;
    END


    // NOTE TODO: all wordlists must be set to have this as the first entry.
    // TODO: code at $PREP_CORE must do it to the standard wordlists.
    // TODO: the VOCABULARY word must do it to new wordlists.
    // TODO: does WORDLIST word also need to do it? Should VOCABULARY /use/ WORDLIST ??
    //
    ANSI PRIMARY root::only                             ( -- )
        vocpContext = &voc_forth;
        searchOrder[0] = &voc_root;
        searchOrder[1] = &voc_forth;
        nSearchOrder = 2;
    END


    ANSI PRIMARY order                                  ( -- )
        // Display the word lists in the search order in their search order sequence, from ﬁrst
        // searched to last searched. Also display the word list into which new deﬁnitions will
        // be placed. The display format is implementation dependent.

        printf("SEARCH ORDER: ");
        for(clTmp = nSearchOrder; clTmp > 0; --clTmp)
            printf("*%tX ", searchOrder[clTmp - 1]);
        printf("CONTEXT: *%tX", vocpContext);
    END


    ANSI PRIMARY previous                               ( -- )
        // drop the top entry of the search order
        // TODO: EXPLODE IF nSearchOrder == 0
        --nSearchOrder;
    END



    //////////////////////////////////////////////////////////////////////
    PRIMARY -noheader $$linebuffer
        SP.cpPush(LineBuffer);
        // SP.push(SIZE_LINEBUF);
        SP.push(LBlen);
    END


    ANSI PRIMARY base                                   ( -- c-addr )
        SP.bpPush(&Base);
    END


    ANSI PRIMARY blk                                    ( -- a-addr )
        SP.clpPush(&Blk);
    END


    ANSI PRIMARY $source_id "source-id"                 ( -- FALSE | TRUE | FILE * )
        SP.cpPush(CharPtr(SourceID));
    END


    ANSI PRIMARY state                                  ( -- a-addr )
        SP.bpPush(&State);
    END


    PRIMARY -noheader $immediate                        ( -- a-addr )
        SP.bpPush(&Immediate);
    END


    PRIMARY context                                     ( -- a-addr )
        SP.push(Cell(&vocpContext));
    END


    PRIMARY current                                     ( -- a-addr )
        // OBSOLETE by get-current
        SP.push(Cell(&vocpCurrent));
    END


    PRIMARY dp                                          ( -- a-addr )
        SP.clppPush(&DP);
    END


    ANSI PRIMARY here                                   ( -- a-addr )   // push DP
        SP.clpPush(DP);
    END


    PRIMARY entry                                       ( -- a-addr )
        SP.clpPush(*vocpCurrent);
    END


    ANSI PRIMARY allot                                  ( n -- )
        DP = CellPtr(Cell(DP) + SP.pop());
    END


    ANSI PRIMARY allocate                               ( u -- a-addr ior )
        clTmp = SP.pop();
        cpTmp = CharPtr(malloc(clTmp));
        SP.cpPush(cpTmp);
        if(cpTmp)
            SP.push(0);
        else {
            slTmp = errno;
            if(! slTmp)
                slTmp = ENOMEM;
            SP.push(slTmp);
        }
    END


    ANSI PRIMARY free                                   ( a-addr -- ior )
        cpTmp = SP.cpPop();
        free(cpTmp);
        SP.push(0);
    END


    ANSI PRIMARY resize                                 ( a-addr1 u -- a-addr2 ior )
        slTmp = SP.pop();
        cpTmp = SP.cpPop();

        cpTmp2 = CharPtr(realloc(cpTmp, slTmp));
        if(cpTmp2) {
            SP.cpPush(cpTmp2);
            SP.push(0);
        }
        else {
            SP.cpPush(cpTmp);
            slTmp = errno;
            if(! slTmp)
                slTmp = ENOMEM;
            SP.push(slTmp);
        }
    END


    ANSI PRIMARY unused                                 ( -- u )
        // TODO: confirm that this is meant to yield nbytes not ncells
        SP.push(CharPtr(Dictionary + SIZE_DICTIONARY) - CharPtr(DP));
    END


    PRIMARY -noheader $$jmp                             ( -- )
        IP += Cell(*IP);
    END


    PRIMARY -noheader $$jmpz                            ( flag -- )
        if(SP.pop() == 0)
            IP += Cell(*IP);
        else
            ++IP;
    END


    PRIMARY -noheader $$jmpnz                           ( flag -- )
        if(SP.pop() != 0)
            IP += Cell(*IP);
        else
            ++IP;
    END


    PRIMARY -noheader $$_add_loop                       ( ofs -- ; R: lim cnt -- lim cnt | )
        slTmp = SP.pop();
        if(sCell(RS[1]) < sCell(RS[2])) {
            RS[1] = CellPtrPtr(Cell(RS[1]) + slTmp);
            // TODO: smarter test, because the target may not hit
            if(sCell(RS[1]) < sCell(RS[2]))
                goto dwc_$$jmp;
        }
        else {
            RS[1] = CellPtrPtr(Cell(RS[1]) + slTmp);
            // TODO: smarter test, because the target may not hit
            if(sCell(RS[1]) >= sCell(RS[2]))
                goto dwc_$$jmp;
        }

        RS.dec(2);
        ++IP;
    END


    PRIMARY -noheader $$loop                            ( R: lim cnt -- lim cnt | )
        if(sCell(RS[1]) < sCell(RS[2])) {
            RS[1] = CellPtrPtr(Cell(RS[1]) + 1);
            if(sCell(RS[1]) != sCell(RS[2]))
                goto dwc_$$jmp;
        }
        else {
            RS[1] = CellPtrPtr(Cell(RS[1]) - 1);
            if(sCell(RS[1]) != sCell(RS[2]))
                goto dwc_$$jmp;
        }

        RS.dec(2);
        ++IP;
    END


    PRIMARY -noheader $$do                              ( lim cnt -- ; R: -- lim cnt )
        RS.inc(2);
        RS[1] = CellPtrPtr(SP[1]);
        RS[2] = CellPtrPtr(SP[2]);
        SP.dec(2);
    END


    PRIMARY -noheader $$question_do                     ( lim cnt -- ; R: --  | lim cnt )
        RS.inc(2);
        RS[1] = CellPtrPtr(SP[1]);
        RS[2] = CellPtrPtr(SP[2]);
        SP.dec(2);

        if(RS[1] != RS[2])
            ++IP;
        else {
            RS.dec(2);
            IP += Cell(*IP);
        }
    END  -- $$question_do


    PRIMARY -noheader $$leave                           ( -- ; R: lim i -- )
        RS.dec(2);
        IP += Cell(*IP);
    END


    ANSI PRIMARY -noheader $$unloop                     ( -- ; R: loop-sys -- )
        RS.dec(2);
    END


    ANSI PRIMARY execute                                ( xt -- )
        WA = SP.clpPop();
        goto $RUN;
    END


    PRIMARY -noheader $$does                            ( -- x ; R: -- x )
        RS.push(IP);
        SP.push(*--WA);
    END


    // although the next 4 words are the same, they have distinct words for the benefit of the SEE word
    PRIMARY -noheader $$create                          ( -- a-addr )
        SP.clpPush(WA);
    END


    PRIMARY -noheader $$variable                        ( -- a-addr )
        SP.clpPush(WA);
    END


    PRIMARY -noheader $$2variable                       ( -- a-addr )
        SP.clpPush(WA);
    END


    PRIMARY -noheader $$fvariable                       ( -- a-addr )
        SP.clpPush(WA);
    END


    PRIMARY -noheader $$value                           ( -- n )
        SP.push(*WA);
    END


    ANSI PRIMARY hex                                    ( -- )
        Base = 16;
    END


    ANSI PRIMARY decimal                                ( -- )
        Base = 10;
    END


    PRIMARY high_bit                                    ( -- n )
        SP.push(HIGH_BIT);
    END


    PRIMARY $_minus_1 "-1"                              ( -- -1 )
        SP.push(-1);
    END


    PRIMARY 0                                           ( -- 0 )
        SP.push(0);
    END


    PRIMARY 1                                           ( -- 1 )
        SP.push(1);
    END


    PRIMARY 2                                           ( -- 2 )
        SP.push(2);
    END


    PRIMARY $_minus_1d "-1."                            ( -- -1. )
        SP.push2(-1);
    END


    PRIMARY $_0d "0."                                   ( -- 0. )
        SP.push2(0);
    END


    PRIMARY $_1d "1."                                   ( -- 1. )
        SP.push2(1);
    END


    PRIMARY $_2d "2."                                   ( -- 2. )
        SP.push2(2);
    END


    ANSI PRIMARY $s_to_d "s>d"                          ( n -- d )
        slTmp = SP.pop();
        SP.push2(slTmp);
    END


    PRIMARY $d_to_s "d>s"                               ( d -- n )
        sl2Tmp = SP.pop2();
        SP.push(Word(sl2Tmp));
    END


    PRIMARY $us_to_ud "us>ud"                           ( u -- ud )
        clTmp = SP.pop();
        SP.push2(clTmp);
    END


    PRIMARY $ud_to_us "ud>us"                           ( ud -- un )
        cl2Tmp = SP.pop2();
        SP.push(Cell(cl2Tmp));
    END


    // STACK OPERATORS
    ANSI PRIMARY depth                                  ( -- u )
        clTmp = SP.depth();
        SP.push(clTmp);
    END


    ANSI PRIMARY drop                                   ( n -- )
        SP.dec();
    END


    ANSI PRIMARY 2drop                                  ( ud -- )
        SP.dec(2);
    END


    ANSI PRIMARY nip                                    ( n2 n1 -- n1 )
        SP[2] = SP[1];
        SP.dec();
    END


    PRIMARY 2nip                                        ( d2 d1 -- d1 )
        SP(3) = SP(1);
        SP.dec(2);
    END


    ANSI PRIMARY tuck                                   ( n2 n1 -- n1 n2 n1 )
        SP.inc();
        SP[1] = SP[2];
        SP[2] = SP[3];
        SP[3] = SP[1];
    END


    PRIMARY 2tuck                                       ( n2 n1 -- n1 n2 n1 )
        SP.inc(2);
        SP(1) = SP(3);
        SP(3) = SP(5);
        SP(5) = SP(1);
    END


    ANSI PRIMARY pick                                   ( nu .. n1 n0 u -- nu .. n1 n0 nu )
        clTmp = SP.pop();
        clTmp = SP[1 + clTmp];
        SP.push(clTmp);
    END


    PRIMARY 2pick                                       ( nu .. n1 n0 u -- nu .. n1 n0 nu )
        clTmp = SP.pop();
        cl2Tmp = SP(1 + clTmp * 2);
        SP.push2(cl2Tmp);
    END


    ANSI PRIMARY roll                                   ( nu .. n1 n0 u -- nu-1 .. n0 nu )
        clTmp = SP.pop();
        clTmp2 = SP[1 + clTmp];
        while(clTmp-- > 0)
            SP[1 + clTmp + 1] = SP[1 + clTmp];
        SP[1] = clTmp2;
    END


    PRIMARY 2roll                                       ( ndu .. nd1 nd0 u -- ndu-1 .. nd0 ndu )
        clTmp = SP.pop();
        cl2Tmp = SP(1 + clTmp * 2);
        while(clTmp-- > 0)
            SP(1 + (clTmp + 1) * 2) = SP(1 + clTmp * 2);
        SP(1) = cl2Tmp;
    END


    ANSI PRIMARY dup                                    ( n1 -- n1 n1 )
        SP.inc();
        SP[1] = SP[2];
    END


    ANSI PRIMARY 2dup                                   ( xd1 xd2 -- xd1 xd2 xd1 xd2 )
        cl2Tmp = SP(1);
        SP.push2(cl2Tmp);
    END


    ANSI PRIMARY $question_dup "?dup"                   ( 0 | n -- 0 | n n )
        if(clTmp = SP[1])
            SP.push(clTmp);
    END


    PRIMARY $question_2dup "?2dup"                      ( 0 | nd -- 0 | nd nd )
        if(cl2Tmp = SP(1))
            SP.push2(cl2Tmp);
    END


    PRIMARY $question_zdup "?!dup"                      ( 0 | n -- 0 0 | n )
        if(! SP[1])
            SP.push(0);
    END


    PRIMARY $question_z2dup "?!2dup"                    ( 0. | nd -- 0. 0. | nd )
        if(! SP(1))
            SP.push2(0);
    END


    PRIMARY dup2                                        ( n1 -- n1 n1 n1 )
        clTmp = SP[1];
        SP.push(clTmp);
        SP.push(clTmp);
    END


    PRIMARY 2dup2                                       ( nd1 -- nd1 nd1 nd1 )
        cl2Tmp = SP(1);
        SP.push2(cl2Tmp);
        SP.push2(cl2Tmp);
    END


    ANSI PRIMARY swap                                   ( n2 n1 -- n1 n2 )
        clTmp = SP[1];
        SP[1] = SP[2];
        SP[2] = clTmp;
    END


    ANSI PRIMARY 2swap                                  ( xd1 xd2 -- xd2 xd1 )
        cl2Tmp = SP(1);
        SP(1) = SP(3);
        SP(3) = cl2Tmp;
    END


    PRIMARY swap2                                       ( n3 n2 n1 -- n1 n2 n3 )
        clTmp = SP[1];
        SP[1] = SP[3];
        SP[3] = clTmp;
    END


    PRIMARY 2swap2                                      ( nd3 nd2 nd1 -- nd1 nd2 nd3 )
        cl2Tmp = SP(1);
        SP(1) = SP(5);
        SP(5) = cl2Tmp;
    END


    ANSI PRIMARY over                                   ( n2 n1 -- n2 n1 n2 )
        clTmp = SP[2];
        SP.push(clTmp);
    END


    ANSI PRIMARY 2over                                  ( xd1 xd2 -- xd1 xd2 xd1 )
        cl2Tmp = SP(3);
        SP.push2(cl2Tmp);
    END


    PRIMARY over2                                       ( n3 n2 n1 -- n3 n2 n1 n3 )
        clTmp = SP[3];
        SP.push(clTmp);
    END


    PRIMARY 2over2                                      ( nd3 nd2 nd1 -- nd3 nd2 nd1 nd3 )
        cl2Tmp = SP[5];
        SP.push2(cl2Tmp);
    END


    ANSI PRIMARY rot                                    ( n3 n2 n1 -- n2 n1 n3 )
        clTmp = SP[3];
        SP[3] = SP[2];
        SP[2] = SP[1];
        SP[1] = clTmp;
    END


    ANSI PRIMARY 2rot                                   ( d3 d2 d1 -- d2 d1 d3 )
        cl2Tmp = SP(5);
        SP(5) = SP(3);
        SP(3) = SP(1);
        SP(1) = cl2Tmp;
    END


    PRIMARY rrot                                        ( n3 n2 n1 -- n1 n3 n2 )
        clTmp = SP[1];
        SP[1] = SP[2];
        SP[2] = SP[3];
        SP[3] = clTmp;
    END


    PRIMARY reverse                                     ( ni .. n1 i -- n1 .. ni )
        slTmp2 = SP.pop();
        slTmp = 1;
        while(slTmp2 > slTmp) {
            clTmp = SP[slTmp];
            SP[slTmp] = SP[slTmp2];
            SP[slTmp2] = clTmp;
            --slTmp2;
            ++slTmp;
        }
    END


    PRIMARY 2rrot                                       ( d3 d2 d1 -- d1 d3 d2 )
        cl2Tmp = SP(1);
        SP(1) = SP(3);
        SP(3) = SP(5);
        SP(5) = cl2Tmp;
    END


    // split native 16 bits to 2 lots of 8 bits
    PRIMARY 2split8
        clTmp = SP[1];
        SP.inc();
        SP[2] = 0xFF & (clTmp >> 8);
        SP[1] = 0xFF &  clTmp;
    END


    // split native 32 bits to 4 lots of 8 bits
    PRIMARY 4split8
        clTmp = SP[1];
        SP.inc(3);
        SP[4] = 0xFF & (clTmp >> 24);
        SP[3] = 0xFF & (clTmp >> 16);
        SP[2] = 0xFF & (clTmp >>  8);
        SP[1] = 0xFF &  clTmp;
    END


    // split native 64 bits to 8 lots of 8 bits
    PRIMARY 8split8
# if __WORDSIZE == 64
        clTmp = SP[1];
        SP.inc(7);

        SP[1] = 0xFF &  clTmp;
        SP[2] = 0xFF & (clTmp >>  8);
        SP[3] = 0xFF & (clTmp >> 16);
        SP[4] = 0xFF & (clTmp >> 24);
        SP[5] = 0xFF & (clTmp >> 32);
        SP[6] = 0xFF & (clTmp >> 40);
        SP[7] = 0xFF & (clTmp >> 48);
        SP[8] = 0xFF & (clTmp >> 56);
# else
        cl2Tmp = *Cell2Ptr(&SP[2]);
        SP.inc(6);

        SP[1] = 0xFF &  cl2Tmp;
        SP[2] = 0xFF & (cl2Tmp >>  8);
        SP[3] = 0xFF & (cl2Tmp >> 16);
        SP[4] = 0xFF & (cl2Tmp >> 24);
        SP[5] = 0xFF & (cl2Tmp >> 32);
        SP[6] = 0xFF & (cl2Tmp >> 40);
        SP[7] = 0xFF & (cl2Tmp >> 48);
        SP[8] = 0xFF & (cl2Tmp >> 56);
# endif
    END -- 8split8


    // split native 32 bits to 2 lots of 16 bits
    PRIMARY 2split16
        clTmp = SP[1];
        SP.inc();
        SP[2] = 0xFFFF & (clTmp >> 16);
        SP[1] = 0xFFFF &  clTmp;
    END


    // split native 64 bits to 4 lots of 16 bits
    PRIMARY 4split16
# if __WORDSIZE == 64
        clTmp = SP[1];
        SP.inc(3);
        SP[1] = 0xFFFF &  clTmp;
        SP[2] = 0xFFFF & (clTmp >> 16);
        SP[3] = 0xFFFF & (clTmp >> 32);
        SP[4] = 0xFFFF & (clTmp >> 48);
# else
        cl2Tmp = *Cell2Ptr(&SP[2]);
        SP.inc(2);

        SP[1] = 0xFFFF &  cl2Tmp;
        SP[2] = 0xFFFF & (cl2Tmp >> 16);
        SP[3] = 0xFFFF & (cl2Tmp >> 32);
        SP[4] = 0xFFFF & (cl2Tmp >> 48);
# endif
    END  -- 4split16


    // split native 64 bits to 2 lots of 32 bits
    PRIMARY 2split32
# if __WORDSIZE == 64
        clTmp = SP[1];
        SP.inc();
        SP[1] = 0xFFFFFFFF &  clTmp;
        SP[2] = 0xFFFFFFFF & (clTmp >> 32);
# else
        cl2Tmp = *Cell2Ptr(&SP[2]);
        SP[1] = 0xFFFFFFFF &  cl2Tmp;
        SP[2] = 0xFFFFFFFF & (cl2Tmp >> 32);
# endif
    END



    // join 2 lots of 8 bits to native 16 bits
    PRIMARY 2join8
        SP[2] = ((SP[2] & 0xFF) << 8)
              |  (SP[1] & 0xFF);
        SP.dec();
    END


    // join 4 lots of 8 bits to native 32 bits
    PRIMARY 4join8
        SP[4] = ((SP[4] & 0xFF) << 24)
              | ((SP[3] & 0xFF) << 16)
              | ((SP[2] & 0xFF) <<  8)
              |  (SP[1] & 0xFF);
        SP.dec(3);
    END


    // join 8 lots of 8 bits to native 64 bits
    PRIMARY 8join8
# if __WORDSIZE == 64
        SP[8] = ((SP[8] & 0xFF) << 56)
              | ((SP[7] & 0xFF) << 48)
              | ((SP[6] & 0xFF) << 40)
              | ((SP[5] & 0xFF) << 32)
              | ((SP[4] & 0xFF) << 24)
              | ((SP[3] & 0xFF) << 16)
              | ((SP[2] & 0xFF) <<  8)
              |  (SP[1] & 0xFF);
        SP.dec(7);
# else
        cl2Tmp = ((SP[8] & 0xFF) << 24)
              | ((SP[7] & 0xFF) << 16)
              | ((SP[6] & 0xFF) <<  8)
              |  (SP[5] & 0xFF);

        cl2Tmp =  (cl2Tmp << 32)
              | ((SP[4] & 0xFF) << 24)
              | ((SP[3] & 0xFF) << 16)
              | ((SP[2] & 0xFF) <<  8)
              |  (SP[1] & 0xFF);
        SP.dec(6);
        *Cell2Ptr(&SP[2]) = cl2Tmp;
# endif
    END  -- 8join8


    // join 2 lots of 16 bits to native 32 bits
    PRIMARY 2join16
        SP[2] = ((SP[2] & 0xFFFF) << 16)
              |  (SP[1] & 0xFFFF);
        SP.dec();
    END


    // join 4 lots of 16 bits to native 64 bits
    PRIMARY 4join16
# if __WORDSIZE == 64
        SP[4] = ((SP[4] & 0xFFFF) << 48)
              | ((SP[3] & 0xFFFF) << 32)
              | ((SP[2] & 0xFFFF) << 16)
              |  (SP[1] & 0xFFFF);
        SP.dec(3);
# else
        cl2Tmp = ((SP[4] & 0xFFFF) << 16)
              |  (SP[3] & 0xFFFF);

        cl2Tmp =  (cl2Tmp << 32)
              | ((SP[2] & 0xFFFF) << 16)
              |  (SP[1] & 0xFFFF);
        SP.dec(2);
        *Cell2Ptr(&SP[2]) = cl2Tmp;
# endif
    END  -- 4join16


    // join 2 lots of 32 bits to native 64 bits
    PRIMARY 2join32
# if __WORDSIZE == 64
        SP[2] = ((SP[2] & 0xFFFFFFFF) << 32)
              |  (SP[1] & 0xFFFFFFFF);
        SP.dec();
# else
        cl2Tmp = SP[2] & 0xFFFFFFFF;

        cl2Tmp = (cl2Tmp << 32)
              | (SP[1] & 0xFFFFFFFF);
        *Cell2Ptr(&SP[2]) = cl2Tmp;
# endif
    END


    // MEMORY REFERENCE OPERATORS
    // !{n}     store SP[2] into *SP[1]; SP.dec(2)
    // +!{n}    add SP[2] into *SP[1]; SP.dec(2)
    // -!{n}    sub SP[2] into *SP[1]; SP.dec(2)
    // @{n}     fetch *SP[1] into SP[1]
    // 0set{n}  store 0 into *SP[1]; SP.dec()
    // 1set{n}  store 1 into *SP[1]; SP.dec()

    ANSI PRIMARY align
        DP = CellPtr((Cell(DP) + sizeof(Cell) - 1) & ~ (sizeof(Cell) - 1));
    END


    ANSI PRIMARY aligned                                ( addr -- a-addr )      // ensure top word of stack is a cell-aligned address
        SP[1] = (SP[1] + sizeof(Cell) - 1) & ~ (sizeof(Cell) - 1);
    END


    ANSI PRIMARY $cstore "c!"                           ( c c-addr -- )
        *CharPtr(SP[1]) = Char(SP[2]);
        SP.dec(2);
    END


    ANSI PRIMARY $store "!"                             ( n a-addr -- )
        *CellPtr(SP[1]) = Cell(SP[2]);
        SP.dec(2);
    END


    ANSI PRIMARY $2store "2!"                           ( x1 x2 a-addr -- )
        clpTmp = SP.clpPop();
        clpTmp[0] = SP.pop();
        clpTmp[1] = SP.pop();
    END


    PRIMARY $cstore_add "c+!"                           ( c c-addr -- )
        *CharPtr(SP[1]) += Char(SP[2]);
        SP.dec(2);
    END


    ANSI PRIMARY $store_add "+!"                        ( n a-addr -- )
        *CellPtr(SP[1]) += Cell(SP[2]);
        SP.dec(2);
    END


    PRIMARY $cstore_sub "c-!"                           ( c c-addr -- )
        *CharPtr(SP[1]) -= Char(SP[2]);
        SP.dec(2);
    END


    PRIMARY $store_sub "-!"                             ( n a-addr -- )
        *CellPtr(SP[1]) -= Cell(SP[2]);
        SP.dec(2);
    END


    ANSI PRIMARY $cell_plus "cell+"                     ( a-adr1 -- a-adr2 )
        SP[1] += sizeof(Cell);
    END


    ANSI PRIMARY cells                                  ( n1 -- n2 )
        SP[1] *= sizeof(Cell);
    END


    PRIMARY 1cell                                       ( -- n )
        SP.push(sizeof(Cell));
    END


    ANSI PRIMARY $char_plus "char+"                     ( c-adr1 -- c-adr2 )
        ++SP[1];
    END


    ANSI PRIMARY chars                                  ( n1 -- n2 )
        // convert stacktop to n*sizeof(Char)
        // ie nothing to do...
    END


    // TODO: make this happen
    ANSI PRIMARY count
        // collect the count
        clTmp = *CellPtr(SP[1]);
        SP[1] += sizeof(Cell);
        SP.push(clTmp);
    END


    ANSI PRIMARY $cfetch "c@"                           ( c-addr -- c )
        SP[1] = *CharPtr(SP[1]) & 0xFF;
    END


    ANSI PRIMARY $fetch "@"                             ( a-addr -- n )
        clpTmp = SP.clpPop();
        // printf("\n\n$fetch from *%tX => %X\n\n", clpTmp, *clpTmp);
        SP.push(*clpTmp);
    END


    ANSI PRIMARY $2fetch "2@"                           ( a-addr -- x1 x2 )
        clpTmp = SP.clpPop();
        SP.push(clpTmp[1]);
        SP.push(clpTmp[0]);
    END


    PRIMARY c0set                                       ( c-addr -- )
        *SP.cpPop() = 0;
    END


    PRIMARY 0set                                        ( a-addr -- )
        *SP.clpPop() = 0;
    END


    PRIMARY c1set                                       ( c-addr -- )
        *SP.cpPop() = 1;
    END


    PRIMARY 1set                                        ( a-addr -- )
        *SP.clpPop() = 1;
    END


    // INTERSTACK OPERATORS
    ANSI PRIMARY $to_r ">r"                             ( x1 -- ; R: -- x1 )
        RS.push(CellPtrPtr(SP.pop()));
    END


    ANSI PRIMARY $2to_r "2>r"                           ( x1 x2 -- ; R: -- x1 x2 )
        clTmp = SP.pop();
        RS.push(CellPtrPtr(SP.pop()));
        RS.push(CellPtrPtr(clTmp));
    END


    ANSI PRIMARY $r_from "r>"                           ( -- x1 ; R: x1 -- )
        SP.push(Cell(RS.pop()));
    END


    ANSI PRIMARY $2r_from "2r>"                         ( -- x1 x2 ; R: x1 x2 -- )
        clTmp = Cell(RS.pop());
        SP.push(Cell(RS.pop()));
        SP.push(clTmp);
    END


    ANSI PRIMARY $copy_return_stack "r@"                ( -- x1 ; R: x1 -- x1 )
        SP.push(Cell(RS[1]));
    END


    ANSI PRIMARY $2copy_return_stack "2r@"              ( -- x1 x2 ; R: x1 x2 -- x1 x2 )
        SP.push(Cell(RS[2]));
        SP.push(Cell(RS[1]));
    END


    ANSI PRIMARY i                                      ( -- i ; R: i -- i )
        SP.push(Cell(RS[1]));
    END


    ANSI PRIMARY j                                      ( -- j ; R: j n i -- j n i )
        SP.push(Cell(RS[3]));
    END


    PRIMARY k                                           ( -- k ; R: k n1 j n2 i -- k n1 j n2 i )
        SP.push(Cell(RS[5]));
    END


    PRIMARY l                                           ( -- l ; R: l n1 k n2 j n3 i -- l n1 k n2 j n3 i )
        SP.push(Cell(RS[7]));
    END


    // MATHS OPERATORS
    ANSI PRIMARY abs                                    ( n1 -- n2 )
        if(sCell(SP[1]) < 0)
            SP[1] = -sCell(SP[1]);
    END


    ANSI PRIMARY dabs                                   ( d1 -- d2 )
        if(sCell2(SP(1)) < 0)
            SP(1) = -sCell2(SP(1));
    END


    PRIMARY sgn                                         ( n1 -- n2 )
        slTmp = SP[1];
        SP[1] = slTmp < 0 ? -1 : slTmp > 0 ? 1 : 0;
    END


    ANSI PRIMARY negate                                 ( n1 -- n2 )
        SP[1] = -SP[1];
    END


    ANSI PRIMARY dnegate                                ( d1 -- d2 )
        SP(1) = -SP(1);
    END


    ANSI PRIMARY $add "+"                               ( n1 n2 -- n3 )
        SP[2] += SP[1];
        SP.dec();
    END


    ANSI PRIMARY $d_add "d+"                            ( d1 d2 -- d3 )
        SP(3) += SP(1);
        SP.dec(2);
    END


    ANSI PRIMARY $m_add "m+"                            ( d1 n -- d2 )
        SP(2) += SP[1];
        SP.dec();
    END


    ANSI PRIMARY $sub "-"                               ( n1 n2 -- n3 )
        SP[2] -= SP[1];
        SP.dec();
    END


    ANSI PRIMARY $d_sub "d-"                            ( d1 d2 -- d3 )
        SP(3) -= SP(1);
        SP.dec(2);
    END


    ANSI PRIMARY $star "*"                              ( n1 n2 -- n3 )
        *sCellPtr(&SP[2]) *= sCell(SP[1]);
        SP.dec();
    END


    PRIMARY $u_mul "u*"                                 ( u1 u2 -- u3 )
        SP[2] *= SP[1];
        SP.dec();
    END


    PRIMARY $d_star "d*"                                ( d1 d2 -- d3 )
        *sCell2Ptr(&SP(3)) *= sCell2(SP(1));
        SP.dec(2);
    END


    PRIMARY $ud_mul "ud*"                               ( ud1 ud2 -- ud3 )
        SP(3) *= SP(1);
        SP.dec(2);
    END


    ANSI PRIMARY $m_star "m*"                           ( n1 n2 -- d )
        sl2Tmp = sCell(SP.pop());
        sl2Tmp2 = sCell(SP.pop());
        SP.push2(sl2Tmp * sl2Tmp2);
    END


    ANSI PRIMARY $um_star "um*"                         ( u1 u2 -- ud )
        cl2Tmp = SP.pop();
        cl2Tmp *= SP.pop();
        SP.push2(cl2Tmp);
    END


    ANSI PRIMARY $div "/"                               ( n1 n2 -- n3 )
        if(SP[1] == 0)
            SPEWING(MESSAGE_DIV0);

        *sCellPtr(&SP[2]) /= sCell(SP[1]);
        SP.dec();
    END


    PRIMARY $u_div "u/"                                 ( u1 u2 -- u3 )
        if(SP[1] == 0)
            SPEWING(MESSAGE_DIV0);

        SP[2] /= SP[1];
        SP.dec();
    END


    PRIMARY $d_div "d/"                                 ( d1 d2 -- d3 )
        if(SP(1) == 0)
            SPEWING(MESSAGE_DIV0);

        *sCell2Ptr(&SP(3)) /= sCell2(SP(1));
        SP.dec(2);
    END


    PRIMARY $ud_div "ud/"                               ( ud1 ud2 -- ud3 )
        if(SP(1) == 0)
            SPEWING(MESSAGE_DIV0);

        SP(3) /= SP(1);
        SP.dec(2);
    END


    ANSI PRIMARY mod                                    ( n1 n2 -- n3 )
        if(SP[1] == 0)
            SPEWING(MESSAGE_DIV0);

        *sCellPtr(&SP[2]) %= sCell(SP[1]);
        SP.dec();
    END


    PRIMARY umod                                        ( u1 u2 -- u3 )
        if(SP[1] == 0)
            SPEWING(MESSAGE_DIV0);

        SP[2] %= SP[1];
        SP.dec();
    END


    PRIMARY dmod                                        ( d1 d2 -- d3 )
        if(SP(1) == 0)
            SPEWING(MESSAGE_DIV0);

        *sCell2Ptr(&SP(3)) %= sCell2(SP(1));
        SP.dec(2);
    END


    PRIMARY udmod                                       ( ud1 ud2 -- ud3 )
        if(SP(1) == 0)
            SPEWING(MESSAGE_DIV0);

        SP(3) %= SP(1);
        SP.dec(2);
    END


    ANSI PRIMARY $star_slash "*/"                       ( n1 n2 n3 -- n4 )
        slTmp = SP.pop();
        slTmp2 = SP.pop();
        if(slTmp == 0)
            SPEWING(MESSAGE_DIV0);

        // for 64 bit platform, this actually needs to use an intermediate 128 bit result
        sl2Tmp = sCell2(sCell(SP.pop())) * slTmp2;
        SP.push(sCell(sl2Tmp / slTmp));
    END


    ANSI PRIMARY $m_star_slash "m*/"                    ( d1 n1 +n2 -- d2 )
        // TODO: NOT COMPLETE!!??!!?!?
        // d1:    dh dl
        // n1:       n1
        //     --------
        //        n1*dl
        //     n1*dh


        // 1 -   ih
        //   -
        // 3 -   il
        //   -
        // 5 n2
        // 6 n1  fh
        // 7 dh  fm
        //   dl  fl

        SP.inc(4);       // 2 double-cells of working space
        SP(1) = sCell2(SP[6]) * sCell2(SP[7]);      // n1 * dh
        SP(3) = sCell2(SP[6]) * sCell2(SP[8]);      // n1 * dl

        // accumulate intermediate 2-cell results into a 3-cell result
        SP[6] = 0;
        SP(7) = SP(3);
        SP(6) += SP(1);
        SP.dec(4);

        // now the hairy bit - divide n2 into flfmfh
        // 1 n2
        // 2 fh
        // 3 fm
        // 4 fl
        // TODO: NOT COMPLETE!!??!!?!?
    END


    ANSI PRIMARY $star_slash_mod "*/mod"                ( n1 n2 n3 -- n4 n5 )
        slTmp = SP.pop();
        slTmp2 = SP.pop();
        if(slTmp == 0)
            SPEWING(MESSAGE_DIV0);

        // for 64 bit platform, this actually needs to use an intermediate 128 bit result
        sl2Tmp = sCell2(sCell(SP.pop())) * slTmp2;
        SP.push(sCell(sl2Tmp % slTmp));
        SP.push(sCell(sl2Tmp / slTmp));
    END


    ANSI PRIMARY $slash_mod "/mod"                      ( n1 n2 -- n3 n4 )
        slTmp = SP.pop();       // n2
        slTmp2 = SP.pop();      // n1

        if(slTmp == 0)
            SPEWING(MESSAGE_DIV0);

        SP.push(slTmp2 % slTmp);
        SP.push(slTmp2 / slTmp);
    END



    ANSI PRIMARY $fm_slash_mod "fm/mod"                 ( d1 n1 -- n2 n3 )
        // ( d1 n1 -- n2 n3 )
        // Divide d1 by n1, giving the floored quotient n3 and the remainder n2.

        // Divide d1 by n1, giving the floored quotient n3 and the remainder n2.
        // Input and output stack arguments are signed.
        slTmp = SP.pop();           // n1
        sl2Tmp = SP.pop2();         // d1
        if(slTmp == 0)
            SPEWING(MESSAGE_DIV0);

        SP.push(sl2Tmp % slTmp);    // remainder SP[2]
        SP.push(sl2Tmp / slTmp);    // quotient  SP[1]

# if DIV_SYMMETRICAL
        if(SP[2] != 0 && slTmp < 0 == sCell(SP[2]) > 0) {
            SP[1]--;
            SP[2] += slTmp;
        }
# endif
    END  -- $fm_slash_mod


    ANSI PRIMARY $sm_slash_rem "sm/rem"                 ( d1 n2 -- n2 n3 )
        // Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
        // Input and output stack arguments are signed.
        slTmp = SP.pop();           // b
        sl2Tmp = SP.pop2();         // a
        if(slTmp == 0)
            SPEWING(MESSAGE_DIV0);

        SP.push(sl2Tmp % slTmp);    // remainder
        SP.push(sl2Tmp / slTmp);    // quotient

# if DIV_FLOORING
        if(SP[2] != 0 && sl2Tmp > 0 == sCell(SP[2]) > 0) {
            SP[1]++;
            SP[2] -= slTmp;
        }
# endif
    END  -- $sm_slash_rem


    ANSI PRIMARY $um_slash_mod "um/mod"                 ( ud u1 -- u2 u3 )
        if(SP[1] == 0)
            SPEWING(MESSAGE_DIV0);

        // Divide ud by u1, giving the quotient u3 and the remainder u2.
        // Input and output stack arguments are unsigned signed.
        clTmp = SP.pop();                   // b
        cl2Tmp = SP.pop2();                 // a
        SP.push(cl2Tmp % clTmp);            // remainder
        SP.push(cl2Tmp / clTmp);            // quotient
    END  -- $um_slash_mod


    PRIMARY $mod_slash "mod/"                           ( n1 n2 -- n3 n4 )
        if(SP[1] == 0)
            SPEWING(MESSAGE_DIV0);

        slTmp = sCell(SP[2]) / sCell(SP[1]);
        *sCellPtr(&SP[2]) %= sCell(SP[1]);
        *sCellPtr(&SP[1]) = slTmp;
    END


    PRIMARY $udiv_mod "u/mod"                           ( u1 u2 -- u3 u4 )
        if(SP[1] == 0)
            SPEWING(MESSAGE_DIV0);

        clTmp = SP[2] % SP[1];
        SP[2] /= SP[1];
        SP[1] = clTmp;
    END


    PRIMARY $umod_div "umod/"                           ( u1 u2 -- u3 u4 )
        if(SP[1] == 0)
            SPEWING(MESSAGE_DIV0);

        clTmp = SP[2] / SP[1];
        SP[2] %= SP[1];
        SP[1] = clTmp;
    END


    ANSI PRIMARY max                                    ( n1 n2 -- n1 | n2 )
        if(sCell(SP[2]) < sCell(SP[1]))
            SP[2] = SP[1];
        SP.dec();
    END


    ANSI PRIMARY dmax                                   ( d1 d2 -- d1 | d2 )
        if(sCell2(SP(3)) < sCell2(SP(1)))
            SP(3) = SP(1);
        SP.dec(2);
    END


    ANSI PRIMARY min                                    ( n1 n2 -- n1 | n2 )
        if(sCell(SP[2]) > sCell(SP[1]))
            SP[2] = SP[1];
        SP.dec();
    END


    ANSI PRIMARY dmin                                   ( n1 n2 -- n1 | n2 )
        if(sCell2(SP(3)) > sCell2(SP(1)))
            SP(3) = SP(1);
        SP.dec(2);
    END


    PRIMARY umax                                        ( u1 n2 -- n1 | n2 )
        if(SP[2] < SP[1])
            SP[2] = SP[1];
        SP.dec();
    END


    PRIMARY umin                                        ( u1 u2 -- u1 | u2 )
        if(SP[2] > SP[1])
            SP[2] = SP[1];
        SP.dec();
    END


    ANSI PRIMARY lshift                                 ( u1 u2 -- u3 )
        SP[2] <<= sCell(SP[1]);
        SP.dec();
    END


    ANSI PRIMARY rshift                                 ( u1 u2 -- u3 )
        SP[2] >>= sCell(SP[1]);
        SP.dec();
    END


    PRIMARY $srshift "s>>"                              ( n1 n2 -- n3 )
        *sCellPtr(&SP[2]) >>= sCell(SP[1]);
        SP.dec();
    END


    ANSI PRIMARY $2star "2*"                            ( n1 -- n2 )
        SP[1] <<= 1;
    END


    ANSI PRIMARY $d_2star "d2*"                         ( d1 -- d2 )
        SP(1) <<= 1;
    END


    ANSI PRIMARY $2slash "2/"                           ( n1 -- n2 )
        *sCellPtr(&SP[1]) >>= 1;
    END


    ANSI PRIMARY $d_2slash "d2/"                        ( d1 -- d2 )
        *sCell2Ptr(&SP(1)) >>= 1;
    END


    ANSI PRIMARY $1plus "1+"                            ( x1 -- x2 )
        SP[1] += 1;
    END


    PRIMARY $2plus "2+"                                 ( x1 -- x2 )
        SP[1] += 2;
    END


    ANSI PRIMARY $1minus "1-"                           ( x1 -- x2 )
        SP[1] -= 1;
    END


    PRIMARY $2minus "2-"                                ( x1 -- x2 )
        SP[1] -= 2;
    END


    ANSI PRIMARY and                                    ( x1 x2 -- x3 )
        SP[2] &= SP[1];
        SP.dec();
    END


    ANSI PRIMARY or                                     ( x1 x2 -- x3 )
        SP[2] |= SP[1];
        SP.dec();
    END


    ANSI PRIMARY xor                                    ( x1 x2 -- x3 )
        SP[2] ^= SP[1];
        SP.dec();
    END


    ANSI PRIMARY invert                                 ( x1 -- x2 )
        SP[1] = ~ SP[1];
    END


    ANSI PRIMARY false                                  ( -- 0 )
        SP.push(0);
    END


    ANSI PRIMARY true                                   ( -- TRUE )
        SP.push(TRUE);
    END


    ANSI PRIMARY $eq "="                                ( x1 x2 -- flag )
        SP[2] = COND(SP[2] == SP[1]);
        SP.dec();
    END


    ANSI PRIMARY $d_eq "d="                             ( d1 d2 -- flag )
        SP[4] = COND(SP(3) == SP(1));
        SP.dec(3);
    END


    ANSI PRIMARY $ne "<>"                               ( x1 x2 -- flag )
        SP[2] = COND(SP[2] != SP[1]);
        SP.dec();
    END


    ANSI PRIMARY $d_ne "d<>"                            ( d1 d2 -- flag )
        SP[4] = COND(SP(3) != SP(1));
        SP.dec(3);
    END


    ANSI PRIMARY $gt ">"                                ( n1 n2 -- flag )
        SP[2] = COND(sCell(SP[2]) > sCell(SP[1]));
        SP.dec();
    END


    ANSI PRIMARY $d_gt "d>"                             ( n1 n2 -- flag )
        SP[4] = COND(sCell2(SP(3)) > sCell2(SP(1)));
        SP.dec();
    END


    ANSI PRIMARY $ugt "u>"                              ( u1 u2 -- flag )
        SP[2] = COND(SP[2] > SP[1]);
        SP.dec();
    END


    ANSI PRIMARY $lt "<"                                ( n1 n2 -- flag )
        SP[2] = COND(sCell(SP[2]) < sCell(SP[1]));
        SP.dec();
    END


    ANSI PRIMARY $d_lt "d<"                             ( d1 d2 -- flag )
        SP[4] = COND(sCell2(SP(3)) < sCell2(SP(1)));
        SP.dec(3);
    END


    ANSI PRIMARY $ult "u<"                              ( u1 u2 -- flag )
        SP[2] = COND(SP[2] < SP[1]);
        SP.dec();
    END


    ANSI PRIMARY $d_ult "du<"                           ( d1 d2 -- flag )
        SP[4] = COND(SP(3) < SP(1));
        SP.dec(3);
    END


    PRIMARY $le "<="                                    ( n1 n2 -- flag )
        SP[2] = COND(sCell(SP[2]) <= sCell(SP[1]));
        SP.dec();
    END


    PRIMARY $d_le "d<="                                 ( d1 d2 -- flag )
        SP[4] = COND(sCell2(SP(3)) <= sCell2(SP(1)));
        SP.dec(3);
    END


    PRIMARY $ule "u<="                                  ( u1 u2 -- flag )
        SP[2] = COND(SP[2] <= SP[1]);
        SP.dec();
    END


    PRIMARY $ge ">="                                    ( n1 n2 -- flag )
        SP[2] = COND(sCell(SP[2]) >= sCell(SP[1]));
        SP.dec();
    END


    PRIMARY $d_ge "d>="                                 ( n1 n2 -- flag )
        SP[4] = COND(sCell2(SP(3)) >= sCell2(SP(1)));
        SP.dec(3);
    END


    PRIMARY $uge "u>="                                  ( u1 u2 -- flag )
        SP[2] = COND(SP[2] >= SP[1]);
        SP.dec();
    END


    ANSI PRIMARY $_0eq "0="                             ( n1 -- flag )
        SP[1] = COND(SP[1] == 0);
    END


    ANSI PRIMARY $d_0eq "d0="                           ( d1 -- flag )
        SP[2] = COND(SP(1) == 0);
        SP.dec();
    END


    ANSI PRIMARY $_0ne "0<>"                            ( n1 -- flag )
        SP[1] = COND(SP[1] != 0);
    END


    PRIMARY $d_0ne "d0<>"                               ( n1 -- flag )
        SP[2] = COND(SP(1) != 0);
        SP.dec();
    END


    ANSI PRIMARY $_0lt "0<"                             ( n1 -- flag )
        SP[1] = COND(sCell(SP[1]) < 0);
    END


    ANSI PRIMARY $d_0lt "d0<"                           ( d1 -- flag )
        SP[2] = COND(sCell2(SP(1)) < 0);
        SP.dec();
    END


    PRIMARY $_0le "0<="                                 ( n1 -- flag )
        SP[1] = COND(sCell(SP[1]) <= 0);
    END


    PRIMARY $d_0le "d0<="                               ( d1 -- flag )
        SP[2] = COND(sCell2(SP(1)) <= 0);
        SP.dec();
    END


    ANSI PRIMARY $_0gt "0>"                             ( n1 -- flag )
        SP[1] = COND(sCell(SP[1]) > 0);
    END


    ANSI PRIMARY $d_0gt "d0>"                           ( n1 -- flag )
        SP[2] = COND(sCell(SP(1)) > 0);
        SP.dec();
    END


    PRIMARY $_0ge "0>="                                 ( n1 -- flag )
        SP[1] = COND(sCell(SP[1]) >= 0);
    END


    PRIMARY $d_0ge "d0>="                               ( n1 -- flag )
        SP[2] = COND(sCell(SP(1)) >= 0);
        SP.dec();
    END


    ANSI PRIMARY within                                 ( n1 n2 n3 -- flag )
        // this is a wierd one - work it out?
        slTmp = FALSE;
        if(SP[2] < SP[1])
            if(SP[2] <= SP[3] and SP[3] < SP[1])
                slTmp = TRUE;

        if(SP[2] > SP[1])
            if(SP[2] <= SP[3] or SP[3] < SP[1])
                slTmp = TRUE;

        SP.dec(2);
        SP[1] = slTmp;
    END  -- within


    PRIMARY rand                                        ( -- n )
        SP.push(rand_r(&seedp));
    END


    PRIMARY srand                                       ( n -- )
        seedp = SP.pop();
    END


    //////////////////////////////////////////////////////////////////////
    // LOGICAL OPERATORS
    PRIMARY $and "&&"                                   ( n1 n2 -- flag )
        SP[2] = COND(SP[2] && SP[1]);
        SP.dec();
    END


    PRIMARY $or "||"                                    ( n1 n2 -- flag )
        SP[2] = COND(SP[2] || SP[1]);
        SP.dec();
    END


    PRIMARY $xor "^^"                                   ( n1 n2 -- flag )
        SP[2] = COND((SP[2] == 0) != (SP[1] == 0));
        SP.dec();
    END


    PRIMARY not                                         ( n1 -- flag )
        SP[1] = SP[1] ? FALSE : TRUE;
    END


    //////////////////////////////////////////////////////////////////////
    // FLOAT OPERATORS
    ANSI PRIMARY fdepth                                 ( -- u )
        clTmp = FP.depth();
        SP.push(clTmp);
    END


    ANSI PRIMARY fdrop                                  ( F: f -- )
        FP.dec();
    END


    ANSI PRIMARY fdup                                   ( F: f -- f f )
        FP.inc();
        FP[1] = FP[2];
    END


    PRIMARY fdup2                                       ( F: f -- f f f )
        FP.inc(2);
        FP[1] = FP[2] = FP[3];
    END


    ANSI PRIMARY fswap                                  ( F: f1 f2 -- f2 f1 )
        fLDTmp = FP[1];
        FP[1] = FP[2];
        FP[2] = fLDTmp;
    END


    ANSI PRIMARY fover                                  ( F: f1 f2 -- f1 f2 f1 )
        FP.inc();
        FP[1] = FP[3];
    END


    PRIMARY frrot                                       ( F: f1 f2 f3 -- f3 f1 f2 )
        fLDTmp = FP[1];
        FP[1] = FP[2];
        FP[2] = FP[3];
        FP[3] = fLDTmp;
    END


    ANSI PRIMARY frot                                   ( F: f1 f2 f3 -- f2 f3 f1 )
        fLDTmp = FP[3];
        FP[3] = FP[2];
        FP[2] = FP[1];
        FP[1] = fLDTmp;
    END


    PRIMARY fover2                                      ( F: f1 f2 f3 -- f1 f2 f3 f1 )
        FP.inc();
        FP[1] = FP[4];
    END


    PRIMARY fswap2                                      ( F: f1 f2 f3 -- f3 f2 f1 )
        fLDTmp = FP[1];
        FP[1] = FP[3];
        FP[3] = fLDTmp;
    END


    ANSI PRIMARY $sffetch "sf@"                           ( n -- ; F: -- f )
        FP.push(*Float32Ptr(SP.cpPop()));
    END


    ANSI PRIMARY $sfstore "sf!"                           ( a-addr -- ; F: f -- )
        *Float32Ptr(SP.cpPop()) = FP.pop();
    END


    ANSI PRIMARY sfalign                                 ( -- )
        DP = CellPtr((Cell(DP) + sizeof(Float32) - 1) / sizeof(Float32) * sizeof(Float32));
    END


    ANSI PRIMARY sfaligned                               ( addr -- f-addr )
        SP[1] = (SP[1] + sizeof(Float32) - 1) / sizeof(Float32) * sizeof(Float32);
    END


    ANSI PRIMARY $sfloat_plus "sfloat+"                   ( f-addr1 -- f-addr2 )
        SP[1] += sizeof(Float32);
    END


    ANSI PRIMARY sfloats                                 ( n1 -- n2 )
        SP[1] *= sizeof(Float32);
    END


    ANSI PRIMARY $dffetch "df@"                           ( n -- ; F: -- f )
        FP.push(*Float64Ptr(SP.cpPop()));
    END


    ANSI PRIMARY $dfstore "df!"                           ( a-addr -- ; F: f -- )
        *Float64Ptr(SP.cpPop()) = FP.pop();
    END


    ANSI PRIMARY dfalign                                 ( -- )
        DP = CellPtr((Cell(DP) + sizeof(Float64) - 1) / sizeof(Float64) * sizeof(Float64));
    END


    ANSI PRIMARY dfaligned                               ( addr -- f-addr )
        SP[1] = (SP[1] + sizeof(Float64) - 1) / sizeof(Float64) * sizeof(Float64);
    END


    ANSI PRIMARY $dfloat_plus "dfloat+"                   ( f-addr1 -- f-addr2 )
        SP[1] += sizeof(Float64);
    END


    ANSI PRIMARY dfloats                                 ( n1 -- n2 )
        SP[1] *= sizeof(Float64);
    END


    ANSI PRIMARY $float_plus "float+"                   ( f-addr1 -- f-addr2 )
        SP[1] += sizeof(FloatLD);
    END


    ANSI PRIMARY floats                                 ( n1 -- n2 )
        SP[1] *= sizeof(FloatLD);
    END


    ANSI PRIMARY $ffetch "f@"                           ( n -- ; F: -- f )
        FP.push(*FloatLDPtr(SP.cpPop()));
    END


    ANSI PRIMARY $fstore "f!"                           ( a-addr -- ; F: f -- )
        *FloatLDPtr(SP.cpPop()) = FP.pop();
    END


    PRIMARY $fstore_add "f+!"                           ( a-addr -- ; F: f -- )
        *FloatLDPtr(SP.cpPop()) += FP.pop();
    END


    PRIMARY $fstore_sub "f-!"                           ( a-addr -- ; F: f -- )
        *FloatLDPtr(SP.cpPop()) -= FP.pop();
    END


    ANSI PRIMARY falign                                 ( -- )
        DP = CellPtr((Cell(DP) + sizeof(FloatLD) - 1) / sizeof(FloatLD) * sizeof(FloatLD));
    END


    ANSI PRIMARY faligned                               ( addr -- f-addr )
        SP[1] = (SP[1] + sizeof(FloatLD) - 1) / sizeof(FloatLD) * sizeof(FloatLD);
    END


    ANSI PRIMARY $f_to_d "f>d"                          ( -- d ; F: r -- )
        SP.push2(sCell2(FP.pop()));
    END


    ANSI PRIMARY $f_to_s "f>s"                          ( -- n ; F: r -- )
        SP.push(sCell(FP.pop()));
    END


    ANSI PRIMARY $s_to_f "s>f"                          ( n -- ; F: -- r )
        FP.push(FloatLD(sCell(SP.pop())));
    END


    ANSI PRIMARY $d_to_f "d>f"                          ( d -- ; F: -- r )
        FP.push(FloatLD(sCell2(SP.pop2())));
    END


    ANSI PRIMARY fnegate                                ( F: f1 -- f2 )
        FP[1] = -FP[1];
    END


    ANSI PRIMARY $fadd "f+"                             ( F: f1 f2 -- f3 )
        FP[2] += FP[1];
        FP.dec();
    END


    ANSI PRIMARY $fsub "f-"                             ( F: f1 f2 -- f3 )
        FP[2] -= FP[1];
        FP.dec();
    END


    ANSI PRIMARY $fmul "f*"                             ( F: f1 f2 -- f3 )
        FP[2] *= FP[1];
        FP.dec();
    END


    ANSI PRIMARY $fdiv "f/"                             ( F: f1 f2 -- f3 )
        FP[2] /= FP[1];
        FP.dec();
    END


    ANSI PRIMARY $f0_lt "f0<"                           ( -- flag ; F: r -- )
        SP.push(COND(0.0 <  FP.pop()));
    END


    PRIMARY $f0_le "f0<="                               ( -- flag ; F: r -- )
        SP.push(COND(0.0 <= FP.pop()));
    END


    ANSI PRIMARY $f0_eq "f0="                           ( -- flag ; F: r -- )
        SP.push(COND(0.0 == FP.pop()));
    END


    PRIMARY $f0_ne "f0<>"                               ( -- flag ; F: r -- )
        SP.push(COND(0.0 != FP.pop()));
    END


    PRIMARY $f0_ge "f0>="                               ( -- flag ; F: r -- )
        SP.push(COND(0.0 >= FP.pop()));
    END


    PRIMARY $f0_gt "f0>"                                ( -- flag ; F: r -- )
        SP.push(COND(0.0 >  FP.pop()));
    END


    ANSI PRIMARY $f_lt "f<"                             ( -- flag ; F: r1 r2 -- )
        SP.push(COND(FP[2] <  FP[1]));
        FP.dec(2);
    END


    PRIMARY $f_le "f<="                                 ( -- flag ; F: r1 r2 -- )
        SP.push(COND(FP[2] <= FP[1]));
        FP.dec(2);
    END


    PRIMARY $f_eq "f="                                  ( -- flag ; F: r1 r2 -- )
        SP.push(COND(FP[2] == FP[1]));
        FP.dec(2);
    END


    PRIMARY $f_ne "f<>"                                 ( -- flag ; F: r1 r2 -- )
        SP.push(COND(FP[2] != FP[1]));
        FP.dec(2);
    END


    PRIMARY $f_ge "f>="                                 ( -- flag ; F: r1 r2 -- )
        SP.push(COND(FP[2] >= FP[1]));
        FP.dec(2);
    END


    PRIMARY $f_gt "f>"                                  ( -- flag ; F: r1 r2 -- )
        SP.push(COND(FP[2] >  FP[1]));
        FP.dec(2);
    END


    ANSI PRIMARY $f_proximate "f~"                      ( -- flag ; F: r1 r2 r3 -- )
        if(! isfinite(FP[1]))
            slTmp = FALSE;                  // a bad r3 is bayd, m'kay?
        else if(FP[1] > 0.0) {
            // If r3 is positive, flag is true if the absolute value of (r1 minus r2) is less than r3.
            if(isfinite(FP[3]) && isfinite(FP[2]))
                slTmp = COND(fabsl(FP[3] - FP[2]) < FP[1]);
            else
                slTmp = FALSE;
        }
        else if(FP[1] < 0.0) {
            // If r3 is negative, flag is true if the absolute value of (r1 minus r2) is less than
            // the absolute value of r3 times the sum of the absolute values of r1 and r2.
            if(isfinite(FP[3]) && isfinite(FP[2]))
                slTmp = COND(fabsl(FP[3] - FP[2]) < -FP[1] * (fabsl(FP[3]) + fabsl(FP[2])));
            else
                slTmp = FALSE;
        }
        else {
            // If r3 is zero, flag is true if the implementation-dependent encoding of r1 and r2 are exactly
            // identical (positive and negative zero are unequal if they have distinct encodings).
            if(isnan(FP[3]) && isnan(FP[2]))
                slTmp = TRUE;
            else if(isinf(FP[3]) == isinf(FP[2]))
                slTmp = TRUE;
            else if(isfinite(FP[3]) && isfinite(FP[2]))
                slTmp = FP[3] == FP[2];
            else
                slTmp = FALSE;
        }

        FP.dec(3);
        SP.push(slTmp);
    END


    PRIMARY $fmod "f%"                                  ( F: f1 f2 -- f3 )
        FP[2] = fmodl(FP[2], FP[1]);
        FP.dec();
    END


    PRIMARY $fdiv_mod "f/%"                             ( F: f1 f2 -- f3 f4 )
        fLDTmp = fmodl(FP[2], FP[1]);
        FP[2] /= FP[1];
        FP[1] = fLDTmp;
    END


    PRIMARY $fmod_div "f%/"                             ( F: f1 f2 -- f3 f4 )
        fLDTmp = FP[2] / FP[1];
        FP[2] = fmodl(FP[2], FP[1]);
        FP[1] = fLDTmp;
    END


    PRIMARY $f10times "f10*"                            ( F: f1 -- f2 )
        FP[1] *= 10.0;
    END


    ANSI PRIMARY facos                                  ( F: f1 -- f2 )
        FP[1] = acosl(FP[1]);
    END


    ANSI PRIMARY facosh                                 ( F: f1 -- f2 )
        FP[1] = acoshl(FP[1]);
    END


    ANSI PRIMARY fasin                                  ( F: f1 -- f2 )
        FP[1] = asinl(FP[1]);
    END


    ANSI PRIMARY fasinh                                 ( F: f1 -- f2 )
        FP[1] = asinhl(FP[1]);
    END


    ANSI PRIMARY fatan                                  ( F: f1 -- f2 )
        FP[1] = atanl(FP[1]);
    END


    ANSI PRIMARY fatan2                                 ( F: f1 -- f2 )
        FP[2] = atan2l(FP[2], FP[1]);
        FP.dec();
    END


    ANSI PRIMARY fatanh                                 ( F: f1 -- f2 )
        FP[1] = atanhl(FP[1]);
    END


    PRIMARY cbrt                                        ( F: f1 -- f2 )
        FP[1] = cbrtl(FP[1]);
    END


    PRIMARY ceil                                        ( F: f1 -- f2 )
        FP[1] = ceill(FP[1]);
    END


    PRIMARY copysign                                    ( F: f1 f2 -- f3 )
        FP[2] = copysignl(FP[2], FP[1]);
        FP.dec();
    END


    ANSI PRIMARY fcos                                   ( F: f1 -- f2 )
        FP[1] = cosl(FP[1]);
    END


    ANSI PRIMARY fcosh                                  ( F: f1 -- f2 )
        FP[1] = coshl(FP[1]);
    END


    PRIMARY drem                                        ( F: f1 f2 -- f3 )
        FP[2] = dreml(FP[2], FP[1]);
        FP.dec();
    END


    PRIMARY erf                                         ( F: f1 -- f2 )
        FP[1] = erfl(FP[1]);
    END


    PRIMARY erfc                                        ( F: f1 -- f2 )
        FP[1] = erfcl(FP[1]);
    END


    ANSI PRIMARY fexp                                   ( F: f1 -- f2 )
        FP[1] = expl(FP[1]);
    END


    PRIMARY exp2                                        ( F: f1 -- f2 )
        FP[1] = exp2l(FP[1]);
    END


    ANSI PRIMARY falog                                  ( F: f1 -- f2 )
        FP[1] = exp10(FP[1]);
    END


    ANSI PRIMARY fexpm1                                 ( F: f1 -- f2 )
        FP[1] = expm1l(FP[1]);
    END


    ANSI PRIMARY fabs                                   ( F: f1 -- f2 )
        FP[1] = fabsl(FP[1]);
    END


    PRIMARY fdim                                        ( F: f1 f2 -- f3 )
        FP[2] = fdiml(FP[2], FP[1]);
        FP.dec();
    END


    ANSI PRIMARY floor                                  ( F: f1 -- f2 )
        FP[1] = floorl(FP[1]);
    END


    PRIMARY fma                                         ( F: f1 f2 f3 -- f4 )
        FP[3] = fmal(FP[3], FP[2], FP[1]);
        FP.dec(2);
    END


    ANSI PRIMARY fmax                                   ( F: f1 f2 -- f3 )
        FP[2] = fmaxl(FP[2], FP[1]);
        FP.dec();
    END


    ANSI PRIMARY fmin                                   ( F: f1 f2 -- f3 )
        FP[2] = fminl(FP[2], FP[1]);
        FP.dec();
    END


    PRIMARY fmod                                        ( F: f1 f2 -- f3 )
        FP[2] = fmodl(FP[2], FP[1]);
        FP.dec();
    END


    PRIMARY frexp                                       ( -- n ; F: f1 -- f2 )
        slTmp = 0;
        FP[1] = frexpl(FP[1], &slTmp);
        SP.push(slTmp);
    END


    PRIMARY hypot                                       ( F: f1 f2 -- f3 )
        FP[2] = hypotl(FP[2], FP[1]);
        FP.dec();
    END


    PRIMARY j0                                          ( F: f1 -- f2 )
        FP[1] = j0l(FP[1]);
    END


    PRIMARY j1                                          ( F: f1 -- f2 )
        FP[1] = j1l(FP[1]);
    END


    PRIMARY jn                                          ( n -- ; F: f1 -- f2 )
        slTmp = SP.pop();
        FP[1] = jnl(slTmp, FP[1]);
    END


    PRIMARY ldexp                                       ( n -- ; F: f1 -- f2 )
        slTmp = SP.pop();
        FP[1] = ldexpl(FP[1], slTmp);
    END


    PRIMARY lgamma                                      ( F: f1 -- f2 )
        FP[1] = lgammal(FP[1]);
    END


    ANSI PRIMARY fln                                    ( F: f1 -- f2 )
        FP[1] = logl(FP[1]);
    END


    ANSI PRIMARY flog                                   ( F: f1 -- f2 )
        FP[1] = log10l(FP[1]);
    END


    ANSI PRIMARY flnp1                                  ( F: f1 -- f2 )
        FP[1] = log1pl(FP[1]);
    END


    PRIMARY log2                                        ( F: f1 -- f2 )
        FP[1] = log2l(FP[1]);
    END


    PRIMARY logb                                        ( F: f1 -- f2 )
        FP[1] = logbl(FP[1]);
    END


    PRIMARY modf                                        ( F: f1 -- f2 f3 )
        FP.push(0.0);
        FP[2] = modfl(FP[2], &FP[1]);
    END


    PRIMARY nearbyint                                   ( F: f1 -- f2 )
        FP[1] = nearbyintl(FP[1]);
    END


    PRIMARY nextafter                                   ( F: f1 f2 -- f3 )
        FP[2] = nextafterl(FP[2], FP[1]);
        FP.dec();
    END


    PRIMARY nexttoward                                  ( F: f1 f2 -- f3 )
        FP[2] = nexttowardl(FP[2], FP[1]);
        FP.dec();
    END


    ANSI PRIMARY $f_star_star "f**"                     ( F: f1 f2 -- f3 )
        FP[2] = powl(FP[2], FP[1]);
        FP.dec();
    END


    PRIMARY remainder                                   ( F: f1 f2 -- f3 )
        FP[2] = remainderl(FP[2], FP[1]);
        FP.dec();
    END


    PRIMARY remquo                                      ( -- n ; F: f1 f2 -- f3 )
        slTmp = 0;
        FP[2] = remquol(FP[2], FP[1], &slTmp);
        SP.push(slTmp);
        FP.dec();
    END


    PRIMARY rint                                        ( F: f1 -- f2 )
        FP[1] = rintl(FP[1]);
    END


    ANSI PRIMARY fround                                 ( F: f1 -- f2 )
        FP[1] = roundl(FP[1]);
    END


    PRIMARY scalb                                       ( n -- ; F: f1 -- f2 )
        clTmp = SP.pop();
        FP[1] = scalbln(FP[1], clTmp);
    END


    PRIMARY significand                                 ( F: f1 -- f2 )
        FP[1] = significandl(FP[1]);
    END


    ANSI PRIMARY fsincos                                ( F: f1 -- f2 f3 )
        FP.inc();
        FP[1] = cosl(FP[2]);
        FP[2] = sinl(FP[2]);
    END


    ANSI PRIMARY fsin                                   ( F: f1 -- f2 )
        FP[1] = sinl(FP[1]);
    END


    ANSI PRIMARY fsinh                                  ( F: f1 -- f2 )
        FP[1] = sinhl(FP[1]);
    END


    ANSI PRIMARY fsqrt                                  ( F: f1 -- f2 )
        FP[1] = sqrtl(FP[1]);
    END


    ANSI PRIMARY ftan                                   ( F: f1 -- f2 )
        FP[1] = tanl(FP[1]);
    END


    ANSI PRIMARY ftanh                                  ( F: f1 -- f2 )
        FP[1] = tanhl(FP[1]);
    END


    PRIMARY tgamma                                      ( F: f1 -- f2 )
        FP[1] = tgammal(FP[1]);
    END


    PRIMARY trunc                                       ( F: f1 -- f2 )
        FP[1] = truncl(FP[1]);
    END


    PRIMARY y0                                          ( F: f1 -- f2 )
        FP[1] = y0l(FP[1]);
    END


    PRIMARY y1                                          ( F: f1 -- f2 )
        FP[1] = y1l(FP[1]);
    END


    PRIMARY yn                                          ( n -- ; F: f1 -- f2 )
        slTmp = SP.pop();
        FP[1] = ynl(slTmp, FP[1]);
    END


    PRIMARY $f_from_i "f<i"                             ( n -- ; F: -- f )
        FP.push(sCell(SP.pop()));
    END


    PRIMARY $i_from_f "f>i"                             ( -- n ; F: f -- )
        SP.push(sCell(FP.pop()));
    END


    PRIMARY $f_from_u "f<u"                             ( u -- ; F: -- f )
        FP.push(Cell(SP.pop()));
    END


    PRIMARY $u_from_f "f>u"                             ( -- u ; F: f -- )
        SP.push(Cell(FP.pop()));
    END


    PRIMARY $f0 "0.0"                                   ( F: -- f )
        FP.push(0.0);
    END


    PRIMARY $f1 "1.0"                                   ( F: -- f )
        FP.push(1.0);
    END


    PRIMARY $fneg1 "-1.0"                               ( F: -- f )
        FP.push(-1.0);
    END


    PRIMARY f2                                          ( F: -- f )
        FP.push(2.0);
    END


    PRIMARY $fneg2 "f-2"                                ( F: -- f )
        FP.push(-2.0);
    END


    PRIMARY $f10 "10.0"                                 ( F: -- f )
        FP.push(10.0);
    END


    PRIMARY nan                                         ( F: -- f )
        FP.push(NAN);
    END


// INF      INFINITY
// INF-
// ZERO+
// ZERO-

    PRIMARY e                                           ( F: -- f )
        FP.push(M_El);
    END


    PRIMARY log2e                                       ( F: -- f )
        FP.push(M_LOG2El);
    END


    PRIMARY log10e                                      ( F: -- f )
        FP.push(M_LOG10El);
    END


    PRIMARY ln2                                         ( F: -- f )
        FP.push(M_LN2l);
    END


    PRIMARY ln10                                        ( F: -- f )
        FP.push(M_LN10l);
    END


    PRIMARY pi                                          ( F: -- f )
        FP.push(M_PIl);
    END


    PRIMARY pi_2                                        ( F: -- f )
        FP.push(M_PI_2l);
    END


    PRIMARY pi_4                                        ( F: -- f )
        FP.push(M_PI_4l);
    END


    PRIMARY 1_pi                                        ( F: -- f )
        FP.push(M_1_PIl);
    END


    PRIMARY 2_pi                                        ( F: -- f )
        FP.push(M_2_PIl);
    END


    PRIMARY 2_sqrtpi                                    ( F: -- f )
        FP.push(M_2_SQRTPIl);
    END


    PRIMARY sqrt2                                       ( F: -- f )
        FP.push(M_SQRT2l);
    END


    PRIMARY sqrt1_2                                     ( F: -- f )
        FP.push(M_SQRT1_2l);
    END


    PRIMARY current_time                                ( -- n )
        SP.push(time(NULL));
    END


    //////////////////////////////////////////////////////////////////
    // STDIO
    ANSI PRIMARY key                                    ( -- c )
        // strictly speaking, sounds like it needs to be in raw mode
        SP.push(getchar());
    END


    ANSI PRIMARY cr                                     ( -- )          // print newline
        putchar('\n');
    END


    ANSI PRIMARY space                                  ( -- )          // print space
        putchar(' ');
    END


    ANSI PRIMARY spaces                                 ( n -- )        // print n spaces
        slTmp = sCell(SP.pop());
        while(slTmp-- > 0)
            putchar(' ');
    END


    ANSI PRIMARY pad                                    ( -- c-addr )
        SP.cpPush(PadBuffer);
    END


    ANSI PRIMARY cpad                                   ( -- c-addr u )
        SP.cpPush(PadBuffer);
        SP.push(SIZE_PADBUF);
    END


    ANSI PRIMARY type                                   ( c-addr u -- )     // print a counted string
        slTmp = SP.pop();
        cpTmp = SP.cpPop();
        while(slTmp-- > 0)
            putchar(*cpTmp++);
    END


    PRIMARY ctype                                       ( c-addr -- )       // print counted string at address
        // TODO: make it work (or maybe WORD ain't workin'...)
        slpTmp = sCellPtr(SP.pop());
        slTmp = *slpTmp++;
        cpTmp = CharPtr(slpTmp);

        while(slTmp-- > 0)
            putchar(*cpTmp++);
    END


    ANSI PRIMARY emit                                   ( x -- )            // print character
        putchar(SP.pop() & 0xFF);
    END


    PRIMARY csz_type                                    ( c-addr -- )       // print C-string at address
        cpTmp = SP.cpPop();
        fputs((char *) cpTmp, stdout);
        fflush(stdout);
    END


    ANSI PRIMARY $less_hash "<#"                        ( -- )
        PnoBuffer.length() = 0;
        cl2Tmp = SP(1);
        SP.push2(cl2Tmp);
    END


    ANSI PRIMARY hold                                   ( char -- )
        cTmp = SP[1];
        for(clTmp = PnoBuffer.length(); clTmp > 0; --clTmp)
            PnoBuffer[clTmp] = PnoBuffer[clTmp - 1];
        PnoBuffer[0] = cTmp;
        ++PnoBuffer.length();
    END


    ANSI PRIMARY sign                                   ( n -- )
        if(sCell2(SP.pop2()) < 0) {
            for(clTmp = PnoBuffer.length(); clTmp > 0; --clTmp)
                PnoBuffer[clTmp] = PnoBuffer[clTmp - 1];
            PnoBuffer[0] = '-';
            ++PnoBuffer.length();
        }
    END


    ANSI PRIMARY $hash "#"                              ( ud1 -- ud1 )
        cTmp = SP(1) % Base;
        SP(1) /= Base;

        cTmp += cTmp >= 10 ? 'A' - 10 : '0';

        for(clTmp = PnoBuffer.length(); clTmp > 0; --clTmp)
            PnoBuffer[clTmp] = PnoBuffer[clTmp - 1];
        PnoBuffer[0] = cTmp;
        ++PnoBuffer.length();
    END  -- $hash


    ANSI SECONDARY $hash_s "#s"                         ( ud1 -- ud2 )
      L1:
        $hash
        2dup or jmpnz(L1)
    END


    ANSI PRIMARY $hash_greater "#>"                     ( xd -- c-addr u )
        PnoBuffer[PnoBuffer.length()++] = ' ';
        SP.cpPush(&PnoBuffer[0]);
        SP.push(PnoBuffer.length());
    END


    ANSI PRIMARY $to_number ">number"                   ( ud1 c-addr u1 -- ud2 c-addr u2 )
        slTmp = SP.pop();
        cpTmp = SP.cpPop();

        while(slTmp > 0) {
            cTmp = *cpTmp;
            if('0' <= cTmp && cTmp <= '9')
                cTmp -= '0';
            else if('a' <= cTmp && cTmp <= 'z')
                cTmp -= 'a' - 10;
            else if('A' <= cTmp && cTmp <= 'Z')
                cTmp -= 'a' - 10;
            else
                break;

            if(cTmp >= Base)
                break;

            SP[1] = SP[1] * Base + cTmp;
            ++cpTmp;
            --slTmp;
        }

        SP.cpPush(cpTmp);
        SP.push(slTmp);
    END  -- $to_number


    PRIMARY $bye "bye!"                                 ( n -- )
        return_code = SP.pop();
        goto $TERMINATE;
    END


    ANSI PRIMARY bye                                    ( -- )
        return_code = 0;
        goto $TERMINATE;
    END


    ANSI PRIMARY bl                                     ( -- c )
        SP.push(' ');
    END


    ANSI PRIMARY fill                                   ( c-addr u char -- )
        cTmp = SP.pop();                // char
        slTmp = SP.pop();               // cnt
        cpTmp = SP.cpPop();             // dst

        while(slTmp-- > 0)
            *cpTmp++ = cTmp;
    END


    ANSI PRIMARY erase                                  ( addr u -- )
        slTmp = SP.pop();
        clpTmp = SP.clpPop();

        while(slTmp-- > 0)
            *clpTmp++ = 0;
    END


    ANSI PRIMARY move                                   ( addr1 addr2 n -- )
        slTmp = SP.pop();               // cnt (signed!)
        clpTmp2 = SP.clpPop();          // dst
        clpTmp = SP.clpPop();           // src

        if(clpTmp > clpTmp2) {          // if src > dst
            // move forwards
            while(slTmp-- > 0)
                *clpTmp2++ = *clpTmp++;
        }
        else if(clpTmp < clpTmp2) {     // if src < dst
            // move backwards
            clpTmp2 += slTmp;
            clpTmp += slTmp;
            while(slTmp-- > 0)
                *--clpTmp2 = *--clpTmp;
        }
    END  -- move


    PRIMARY sleep                                       ( u -- )
        sleep(SP.pop());
    END


    ANSI SECONDARY $d_dot "d."                          ( d -- )
        $less_hash dabs $hash_s 2drop sign $hash_greater
        type
    END


    SECONDARY $2udot "2u."                              ( du -- )
        $less_hash $hash_s 2drop $hash_greater
        type
    END


    ANSI SECONDARY $dot "."                             ( n -- )
        $s_to_d $d_dot
    END


    ANSI SECONDARY $udot "u."                           ( u -- )
        $us_to_ud $2udot
    END


    ANSI PRIMARY $dot_r ".r"                            ( n n -- )
        slTmp = SP.pop();
        printf("%*d ", slTmp, SP.pop());
    END


    ANSI PRIMARY $udot_r "u.r"                          ( u n -- )
        slTmp = SP.pop();
        printf("%*u ", slTmp, SP.pop());
    END


    ANSI PRIMARY $d_dot_r "d.r"                         ( d n -- )
        slTmp = SP.pop();
        printf("%*lld ", slTmp, SP.pop2());
    END


    PRIMARY $2u_dot_r "2u.r"                            ( du n -- )
        slTmp = SP.pop();
        printf("%*llu ", slTmp, SP.pop2());
    END


    PRIMARY $dot_dot ".."                               ( n -- n )
        printf("%d ", SP[1]);
    END


    PRIMARY $u_dot_dot "u.."                            ( u -- u )
        printf("%u ", SP[1]);
    END


    PRIMARY $2_dot_dot "2.."                            ( d -- d )
        printf("%lld ", SP(1));
    END


    PRIMARY $2u_dot_dot "2u.."                          ( du -- du )
        printf("%lld ", SP(1));
    END


    PRIMARY $x_dot "x."                                 ( u -- )
        printf("%X ", SP.pop());
    END


    PRIMARY $tx_dot "tx."                               ( u -- )
        printf("*%tX ", SP.pop());
    END


    PRIMARY $2x_dot "2x."                               ( du -- )
        printf("%llX ", SP.pop2());
    END


    ANSI PRIMARY $f_dot "f."                            ( f -- )
        printf("%.*LG ", Precision, FP.pop());
    END


    ANSI PRIMARY $fs_dot "fs."                          ( f -- )
        printf("%.*LE ", Precision, FP.pop());
    END


    ANSI PRIMARY precision                              ( -- u )
        SP.push(Precision);
    END


    ANSI PRIMARY $set_precision "set-precision"         ( -- u )
        Precision = SP.pop();
        // arbitrary sensibility limit
        if(Precision > 64)
            Precision = 64;
    END


    PRIMARY ascii                                       ( n -- c )
        slTmp = SP[1] & 0xFF;
        if(slTmp < 10)
            slTmp += '0';
        else
            slTmp += 'A' - 10;
        SP[1] = slTmp;
    END


    //////////////////////////////////////////////////////////////////
    PRIMARY -noheader $$fail
        SPEWING(MESSAGE_QUE);
    END


    ANSI PRIMARY $ccomma "c,"
        cpTmp = CharPtr(DP);
        *cpTmp++ = SP.pop();
        DP = CellPtr(cpTmp);
    END


    PRIMARY $2comma "2,"
        cl2pTmp = Cell2Ptr(DP);
        *cl2pTmp++ = SP.pop2();
        DP = CellPtr(cl2pTmp);
    END  -- $2comma


    ANSI PRIMARY $comma ","
        *DP++ = SP.pop();
    END


    PRIMARY $fcomma "f,"
        *FloatLDPtr(DP) = FP.pop();
        DP = CellPtr(CharPtr(DP) + sizeof(FloatLD));
    END


    PRIMARY -noheader $$literal
        SP.push(Cell(*IP++));
    END


    PRIMARY -noheader $$2literal
        SP.push2(*Cell2Ptr(IP));
        IP += 2;
    END


    PRIMARY -noheader $$fliteral
        FP.push(*FloatLDPtr(IP));
        IP = CellPtrPtr(CharPtr(IP) + sizeof(FloatLD));
    END


    PRIMARY -noheader $$sliteral
        clTmp = Cell(*IP++);
        SP.push(Cell(IP));
        SP.push(clTmp);
        IP = CellPtrPtr(CharPtr(IP) + (clTmp + sizeof(Cell) - 1) / sizeof(Cell) * sizeof(Cell));
    END


    PRIMARY $sp "?sp"
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        clpTmp = SP.ptr();
        if(SP.underflow())
            SP.clear();
        SP.clpPush(clpTmp);
    END


    PRIMARY $rs_fetch "rp@"                          ( -- addr )
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        clTmp = Cell(RS.ptr());
        SP.push(clTmp);
    END


    PRIMARY $rs_store "rp!"                          ( addr -- )
        clTmp = SP.pop();
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        RS.ptr() = (CellPtrPtr *)(clTmp);
    END


    PRIMARY $sp_fetch "sp@"                          ( -- addr )
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        clTmp = Cell(SP.ptr());
        SP.push(clTmp);
    END


    PRIMARY $sp_store "sp!"                          ( addr -- )
        clTmp = SP.pop();
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        SP.ptr() = CellPtr(clTmp);
    END


    PRIMARY $fp_fetch "fp@"
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        clTmp = Cell(FP.ptr());
        SP.push(clTmp);
    END


    PRIMARY $fp_store "fp!"
        clTmp = SP.pop();
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        FP.ptr() = FloatLDPtr(clTmp);
    END


    PRIMARY $os_fetch "os@"
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        clTmp = Cell(OS.ptr());
        SP.push(clTmp);
    END


    PRIMARY $os_store "os!"
        clTmp = SP.pop();
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        OS.ptr() = (OP *)(clTmp);
    END


    PRIMARY $sp_clear
        SP.clear();
    END


    PRIMARY $rs "?rs"                                   ( -- n ; R: n -- n )
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        SP.push(Cell(RS.ptr()));
    END


    PRIMARY $add_sp "+sp"                               ( n -- addr )
        clTmp = SP.pop();
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        clTmp += Cell(SP.ptr());
        SP.push(clTmp);
    END


    PRIMARY $sub_sp "-sp"                               ( n -- addr )
        clTmp = SP.pop();
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        clTmp -= Cell(SP.ptr());
        SP.push(clTmp);
    END


    ANSI PRIMARY $dot_s ".s"                            ( -- )              // print the stack non-destructively, bottom to top
        clTmp = SP.depth();
        while(clTmp > 0)
            printf("%d ", SP[clTmp--]);
    END


    PRIMARY $dot_sp ".sp"                               ( -- )              // print the stack non-destructively, top to bottom
        clTmp = SP.depth();
        clTmp2 = 0;
        while(clTmp-- > 0)
            printf("%d ", SP[++clTmp2]);
    END


    ANSI SECONDARY question "?"                         ( a-addr -- )       // print cell at address
        $fetch
        $dot
    END


    ANSI PRIMARY dump                                   ( addr u -- )       // print n cells at address
        slTmp = SP.pop();
        clpTmp = SP.clpPop();

        while(slTmp-- > 0)
            printf("%d ", *clpTmp++);
    END


    ANSI PRIMARY accept                                 ( c-addr +n1 -- +n2 )
        slTmp = SP.pop();
        cpTmp = SP.cpPop();
        SP.push(0);

        while((clTmp = fgetc(stdin)) != EOF && clTmp != '\n') {
            if(slTmp > 0) {
                *cpTmp++ = clTmp;
                SP[1]++;
            }
        }
    END  -- accept


    ANSI PRIMARY $$token                                ( ch -- )
        clTmp = SP.pop();                   // get the delimiter
        clpTmp = DP;                        // first word of Dictionary will be the length cell
        cpTmp = CharPtr(clpTmp + 1);        // characters to be stored after the length

        // the high bit flags special treatment for use by WORD word
        slTmp = (clTmp & HIGH_BIT) != 0;
        clTmp &= ~ HIGH_BIT;

        // printf("  > $$token '\\%03o' %d<%.*s>[%d]%s\n", clTmp, LBlen, LBlen, LBsrc, LBofs, slTmp ? " HI" : MESSAGE_SILENT);

        // if(slTmp)
        //     printf("%c %d\n", clTmp, slTmp);

        // if(clTmp != ' ')
        //     printf("Separator is %d (%c)\n", clTmp, clTmp);

        LBsrc[SIZE_LINEBUF] = '\0';         // protect our arse
        if(clTmp == ' ') {
            // skip leading spaces
            while(LBofs < LBlen && isspace(LBsrc[LBofs]))
                ++LBofs;
        }
        else if(slTmp) {        // special WORD treatment
            // only WORD wants to skip it's delimiter before the real token is collected
            while(LBofs < LBlen && LBsrc[LBofs] && LBsrc[LBofs] == clTmp)
                ++LBofs;
        }

        // gather the token
        while(LBofs < LBlen && LBsrc[LBofs] && LBsrc[LBofs] != clTmp) {
            // if space is the delimiter, break on all whitespace characters
            if(clTmp == ' ' && isspace(LBsrc[LBofs]))
                break;

            if(clTmp != '"')
                *cpTmp++ = LBsrc[LBofs++];
            else {
                // only " type string collection allows C-like escapes
                clTmp2 = oneChar();
                if(clTmp2 == -1)
                    break;
                *cpTmp++ = clTmp2;
            }
        }

        // skip trailing spaces
        if(clTmp == ' ') {
            while(LBofs < LBlen && isspace(LBsrc[LBofs]))
                ++LBofs;
        }
        else {
            if(LBofs < LBlen && LBsrc[LBofs] == clTmp)
                ++LBofs;
            // else TODO: complain about lack of terminator (unless the delim is '\n')
        }

        *clpTmp = cpTmp - CharPtr(clpTmp + 1);     // evaluate length of string and store;
        // if(slTmp || clTmp != ' ')
        //     printf("  < $$token %d: <%.*s>\n", *clpTmp, *clpTmp, CharPtr(clpTmp + 1));
    END  -- $$token


    PRIMARY -noheader $here_to_word_buf
        // the string is expected to be in the free space of the dictionary
        // the string is copied to the word buffer PnoBuffer
        // then the address of PnoBuffer is pushed - points to the length cell, which is followed by the text

        clTmp = *DP;                    // first word is the length, and the string follows
        cpTmp = CharPtr(DP + 1);

        // truncate if needed (including stealing 1 for the required trailing space)
        if(clTmp > SIZE_PNOBUF - 1)
            clTmp = SIZE_PNOBUF - 1;

        // transfer the length, string bytes and a bonus space (some words like to have it there)
        PnoBuffer.length() = clTmp;
        for(clTmp2 = 0; clTmp2 < clTmp; ++clTmp2)
            PnoBuffer[clTmp2] = cpTmp[clTmp2];
        PnoBuffer[clTmp2] = ' ';

        // push the address of the buffer
        SP.push(Cell(&PnoBuffer));
    END


    ANSI SECONDARY word                                 ( char "<chars>ccc<char" -- c-addr )
        high_bit or $$token
        $here_to_word_buf       // copy it to the PnoBuffer
    END  -- word


    ANSI SECONDARY parse                                ( char "ccc<char>" -- c-addr u )
        $$token
        $here_to_word_buf
        count
    END


    ANSI PRIMARY $environment_query "environment?"      ( c-addr u -- false | i*x true )
        slTmp = SP.pop();
        cpTmp = SP.cpPop();

        for(slTmp2 = 0; envir[slTmp2].length; ++slTmp2) {
            if(slTmp == envir[slTmp2].length && ! strncasecmp(cpTmp, envir[slTmp2].name, slTmp)) {
                if(envir[slTmp2].handler)
                    goto *VoidPtr(Cell(&&$$HEAD) + envir[slTmp2].handler);

                SP.push(envir[slTmp2].value);
                SP.push(TRUE);
                next;
            }
        }

        SP.push(0);     // failure to find the string
    END


    SECONDARY environment                               ( "<spaces>name" -- false | i*x true )
        bl $$token $here_to_word_buf count $environment_query
    END


    PRIMARY -noheader $$dot_quote
        cpTmp = CharPtr(CellPtr(IP) + 1);
        slTmp = Cell(*IP);
        skip_string();

        while(slTmp-- > 0)
            putchar(*cpTmp++);
    END


    PRIMARY -noheader $$c_quote
        SP.push(Cell(IP));
        skip_string();
    END


    PRIMARY -noheader $$csz_quote
        // push only the C string - ignore the stored length
        SP.push(Cell(IP + 1));
        skip_string();
    END


    PRIMARY -noheader $$s_quote
        cpTmp = CharPtr(IP + 1);
        slTmp = Cell(*IP);
        SP.cpPush(cpTmp);
        SP.push(slTmp);
        skip_string();
    END


    PRIMARY -noheader $$abort_quote
        cpTmp = CharPtr(IP + 1);
        slTmp = Cell(*IP);
        skip_string();

        if(SP.pop()) {
            while(slTmp-- > 0)
                putchar(*cpTmp++);

            goto $ABORT;
        }
    END  -- $$abort_quote


    PRIMARY $to_name ">name"                            ( ep -- c-addr )
        clpTmp = SP.clpPop();

        clpTmp2 = nameOfXT(specs, Dictionary, CellPtr(&clpTmp));
        SP.clpPush(clpTmp2);
    END


    SECONDARY $to_link ">link"                          ( ep -- a-addr )
        // convert address of entry into address of the entries-link by skipping the name and it's length
        dup                                         // ep ep
          $fetch                                    // ep *ep
          $cell_plus                                // ep (*ep + sizeof Cell)
        $add                                        // (ep + *ep + sizeof Cell)
        // need to align 'cos the name may be any length
        aligned                                     // aligned(ep + *ep + sizeof Cell)
    END


    SECONDARY $to_code ">code"                          ( xt -- a-addr )
        $to_link
        $cell_plus
    END


    ANSI SECONDARY $to_body ">body"                     ( xt -- a-addr )
        $to_code
        $cell_plus
    END


    ANSI PRIMARY $to_in ">in"                           ( -- a-addr )
        SP.clpPush(&LBofs);
    END


    SECONDARY $ca_store "ca!"
        entry $to_code
        $store
    END


    SECONDARY -noheader _token_for_create
        here        // save DP - if $$token fails, restore to undo the align
        align       // align DP to next cell
        bl $$token  // get a blank-delimited token

        // bail out if failed to get a token - indicated by zero length at *DP
        here $fetch jmpnz(L1)
        dp $store   // restore the possibly unaligned DP
        $$fail

      L1:
        drop        // get rid of the stored pre-align DP
    END


    SECONDARY create
        _token_for_create

        // enclose name into vocab
        // store DP into vocab and then point this one to saved entry
        entry               // address of top word in current vocab

          // set current vocab to point to the new entry
          here              // DP
          current $fetch    // contents of vocpCurrent
          $store            // store DP to current vocab

          // bump DP to point to the link
          here $to_link
          dp $store           // store

        $comma              // link to last entry (stacked above) is stored into link

        // NOW:
        //  previous top word is pointed to by this new top entry,
        //  the current vocab now points to this word,
        //  DP has been bumped by the size of the name and the length of the name and then aligned
        //  DP points to where the code address has to be stored

        // NOTE: Loeliger set the code address to the address of the next cell in anticipation of this word being a primary
        // ANSI: set code address to a call wot stacks the address of next free cell - allot, : etc can then be used
        //
        // $$create acts like $$variable, but it's distinct for the benefit of the SEE word
        // it pushes WA which is the address of the next word. When defining other types of word,
        // the code address is replaced using $ca_store - eg : replaces it with $COLON
        //
        dwc($$create) $comma
    END  -- create


    PRIMARY -noheader $clean_locals
        cleanLocals();
    END


    PRIMARY -noheader $$localize
        slTmp = Cell(*IP++);
        RS.push(CellPtrPtr(localBase));
        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        localBase = RS.ptr();

        // push from SP to RS - make sure the order is correct!
        // low byte encodes the count of initialized locals
        // next byte encodes the count of uninitialized locals
        while((slTmp & 0xFF)) {
            --slTmp;
            RS.push(SP.clppPop());
        }

        // TODO: does it cope with the change of sp pointing to the top entry, not past it?
        RS.ptr() += (slTmp >> 8) & 0xFF;
    END


    PRIMARY -noheader $$_local_$$                           ( c-addr u type -- )
        slTmp = SP.pop();
        clTmp = SP.pop();
        cpTmp = SP.cpPop();

        if(clTmp) {
            if(nLocals >= MAX_LOCALS) {
                // TODO: proper error messaging
                printf("Too many locals defined\n");
                goto $PATCH;
            }

            if(! (locals[nLocals].cp = strndup(cpTmp, clTmp))) {
                printf("out of memory when storing name of local\n");
                goto $PATCH;
            }

            locals[nLocals].nLength = clTmp;
            locals[nLocals].initialized = slTmp;
            ++nLocals;
        }
        else {
            *DP++ = Cell(CODE_ADDRESS($$localize));
            // encode the initialized and uninitialized counts
            slTmp = 0;
            clTmp = nLocals;
            while(clTmp > 0)
                slTmp += locals[--clTmp].initialized ? 1 : 0x100;
            *DP++ = slTmp;
        }
    END


    ANSI SECONDARY $_local_$ "(local)"                  ( c-addr u -- )
        1       // flag as an initialized local
        $$_local_$$
    END


    ANSI SECONDARY -immediate $locals_pipe "locals|"    ( UNDEF / C: "<spaces>name1" ... "<spaces>namen" | -- / / -- ; R: xn ... x2 x1 -- )
      L1:
        bl word count

        // see if it's a pipe word
        over $cfetch '|' $sub       // compare with '|'
        over 1 $sub                 // check the length
        or      // composite
        jmpz(L0)

        $_local_$
        jmp(L1)

      L0:
        2drop
        0 0 $_local_$
    END


    ANSI SECONDARY -immediate $locals_braced "{:"   ( UNDEF / C: "<spaces>name" ... [ '|' "<spaces>name" ...] [ '--' crap ":}" | -- / / -- ; R: xn .. x2 x1 -- )
      L1:
        bl word count

        // see if it's got the length for the '--' or ':}' words
        dup 2 $eq jmpz(L2)

        // see if it's the "--" word
        over dup $cfetch '-' $eq        // compare to '-'
        swap $1plus $cfetch '-' $eq     // compare to '-'
        and jmpnz(L6)

        // see if it's the ":}" word
        over dup $cfetch ':' $eq        // compare to ':'
        swap $1plus $cfetch '}' $eq     // compare to '}'
        and jmpnz(L0)

      L2:
        // see if it's a pipe word
        over $cfetch '|' $eq        // compare with '|'
        over 1 $eq                  // check the length
        and jmpnz(L3)

        // must be a name word for an initialized local
        1 $$_local_$$ jmp(L1)

      L3:
        2drop

      L4:
        // loop to get uninitialized names
        bl word count

        // see if it's got the length for the '--' or ':}' words
        dup 2 $eq jmpz(L5)

        // see if it's the "--" word
        over dup $cfetch '-' $eq        // compare to '-'
        swap $1plus $cfetch '-' $eq     // compare to '-'
        and jmpnz(L6)

        // see if it's the ":}" word
        over dup $cfetch ':' $eq        // compare to ':'
        swap $1plus $cfetch '}' $eq     // compare to '}'
        and jmpnz(L0)

      L5:
        // must be a name word for an uninitialized local
        0 $$_local_$$ jmp(L4)

      L6:
        // search for ':}' word
        2drop
        bl word count

        // see if it's got the length for the ':}' word
        dup 2 $eq jmpz(L6)

        // see if it's the ":}" word
        over dup $cfetch ':' $eq        // compare to ':'
        swap $1plus $cfetch '}' $eq     // compare to '}'
        and jmpz(L6)

      L0:
        // all finished
        2drop
        0 0 0 $$_local_$$
    END


    PRIMARY -noheader $$glocal
        SP.clppPush(localBase[Cell(*IP++)]);
    END


    PRIMARY -noheader $$slocal
        localBase[Cell(*IP++)] = SP.clppPop();
    END


    PRIMARY set_local                               ( x i -- )
        slTmp = SP.pop();
        localBase[slTmp] = SP.clppPop();
    END


    PRIMARY -noheader $$find_local                  ( c-addr n -- FALSE | n TRUE )
        slTmp = SP.pop();
        cpTmp = SP.cpPop();

        for(clTmp = 0; clTmp < nLocals; ++clTmp)
            if(slTmp == locals[clTmp].nLength && ! strncmp(cpTmp, locals[clTmp].cp, slTmp)) {
                SP.push(clTmp);
                SP.push(TRUE);
                next;
            }

        SP.push(FALSE);
    END


    SECONDARY -noheader $glocal                     ( -- FALSE | TRUE )
        state $cfetch jmpz(L1)
        here count $$find_local jmpz(L1)

        adr($$glocal) $comma $comma true jmp(L0)

      L1:
        false
      L0:
    END


    SECONDARY -noheader $slocal                     ( -- FALSE | TRUE )
        state $cfetch jmpz(L1)
        here count $$find_local jmpz(L1)

        adr($$slocal) $comma $comma true jmp(L0)

      L1:
        false
      L0:
    END


    ANSI SECONDARY $colon ":"
        current $fetch
        context $store

        create

        // replace goto offset with offset of $COLON for secondary execution
        literal(GOTO_ADR($COLON)) $ca_store

        state c1set          // set compile mode
    END  -- $colon


    ANSI SECONDARY $colon_noname ":noname"
        here
        literal(GOTO_ADR($COLON)) $comma
        state c1set
    END  -- $colon_noname


    ANSI SECONDARY constant
        create
        $comma      // store value on data stack into the constant

    :CODE:
        SP.push(*WA++);
    END


    ANSI SECONDARY 2constant
        create
        $2comma    // store value on data stack into the constant

    :CODE:
        SP.push2(*Cell2Ptr(WA));
        WA += 2;
    END


    ANSI SECONDARY fconstant
        create
        $fcomma    // store value on float stack into the constant

    :CODE:
        FP.push(*FloatLDPtr(WA));
        WA = CellPtr(CharPtr(WA) + sizeof(FloatLD));
    END


    ANSI SECONDARY variable                             ( "<spaces>name" -- / / / -- a-addr )
        0
        constant
        dwc($$variable) $ca_store
    END


    ANSI SECONDARY 2variable                            ( "<spaces>name" -- / / / -- a-addr )
        $_0d
        2constant
        dwc($$2variable) $ca_store
    END


    ANSI SECONDARY fvariable                            ( "<spaces>name" -- / / / -- a-addr )
        $f0
        fconstant
        dwc($$fvariable) $ca_store
    END


    SECONDARY $builds "<builds"
        0 constant
    END


    ANSI SECONDARY $does "does>"                        ( UNDEF / C: colon-sys1 -- colon-sys2 / / --  R: nest-sys1 -- )
        $r_from
        entry $to_body
        $store
        // TODO: deallocate locals?

    :CODE:
        RS.push(IP);
        IP = CellPtrPtr(*WA++);
        SP.clpPush(WA);
    END


    // SECONDARY vocabulary
    //     $builds entry $comma
    //     $does context $store
    // END

    // PRIMARY definitions
    //     vocpCurrent = vocpContext;
    // END

    ANSI SECONDARY immediate
        entry $fetch literal(IMMEDIATE_BIT) or
        entry $store
    END


    SECONDARY field
        create
        over $comma
        $add

        $does $fetch $add
    END


    SECONDARY struct
        0
    END


    //////////////////////////////////////////////////////////////////////
    // FILE word set

    // TODO: extend ( see 11.6.1.0080


    // include-file ( i*x fileid -- j*x )


    // included ( i*x c-addr u -- j*x )


    PRIMARY -noheader $$prep_fam
        clTmp = SP.pop() & ~ TIL_FILE_BIN;  // deal with BIN later
    END


    PRIMARY -noheader $$prep_fname
        clTmp2 = SP.pop();
        cpTmp = SP.cpPop();
        if(clTmp2 >= PATH_MAX)
            clTmp2 = PATH_MAX - 1;
        strncpy(FOpenName, cpTmp, clTmp2);
        FOpenName[clTmp2] = '\0';
    END


    ANSI PRIMARY $r_o "r-o"                                 ( -- fam )
        SP.push(TIL_FILE_RO);
    END


    ANSI PRIMARY $w_o "w-o"                                 ( -- fam )
        SP.push(TIL_FILE_WO);
    END


    ANSI PRIMARY $r_w "r-w"                                 ( -- fam )
        SP.push(TIL_FILE_RW);
    END


    ANSI PRIMARY bin                                        ( fam1 -- fam2 )
        SP[1] |= TIL_FILE_BIN;
    END


    PRIMARY -noheader $$create_file
        if(clTmp == TIL_FILE_RO) {      // can't create for read-only
            SP.push(0);
            SP.push(EINVAL);
        }
        else {
            fdTmp = fopen(FOpenName, clTmp == TIL_FILE_WO ? "w" : "w+");
            SP.push(Cell(fdTmp));
            if(fdTmp)
                SP.push(0);
            else
                SP.push(errno);
        }
    END


    ANSI SECONDARY $create_file "create-file"               ( c-addr u fam -- fileid ior )
        $$prep_fam $$prep_fname $$create_file
    END


    PRIMARY -noheader $$open_file
        switch(clTmp) {
          case TIL_FILE_RO: cpTmp2 = (char *) "r";  break;
          case TIL_FILE_WO: cpTmp2 = (char *) "w";  break;
          case TIL_FILE_RW: cpTmp2 = (char *) "r+"; break;
          default:          cpTmp2 = (char *) "r";
        }

        fdTmp = fopen(FOpenName, cpTmp2);
        SP.push(Cell(fdTmp));
        SP.push(fdTmp ? 0 : errno);
    END


    ANSI SECONDARY $open_file "open-file"                   ( c-addr u fam -- fileid ior )
        $$prep_fam $$prep_fname $$open_file
    END


    ANSI PRIMARY $close_file "close-file"                   ( fileid -- ior )
        fdTmp = (FILE *) SP.pop();
        prep_ior(fclose(fdTmp));
    END


    PRIMARY -noheader $$delete_file
        prep_ior(unlink(FOpenName));
    END


    ANSI SECONDARY $delete_file "delete-file"               ( c-addr u -- ior )
        $$prep_fname $$delete_file
    END


    ANSI PRIMARY $file_position "file-position"             ( fileid -- ud ior )
        fdTmp = (FILE *) SP.pop();
        cl2Tmp = Cell2(ftello(fdTmp));
        SP.push2(cl2Tmp);
        SP.push(cl2Tmp == -1 ? errno : 0);
    END


    ANSI PRIMARY $reposition_file "reposition-file"         ( ud fileid -- ior )
        fdTmp = (FILE *) SP.pop();
        cl2Tmp = SP.pop2();
        prep_ior(fseeko(fdTmp, off_t(cl2Tmp), SEEK_SET));
    END


    PRIMARY $$file_status
        SP.push(-1);
        prep_ior(stat(FOpenName, &stat_buf));
        if(SP[1] == 0)
            SP[2] = stat_buf.st_mode;
    END


    ANSI SECONDARY $file_status "file-status"               ( c-addr u -- x ior )
        $$prep_fname $$file_status
    END


    ANSI PRIMARY $flush_file "flush-file"                   ( fileid -- ior )
        fdTmp = (FILE *) SP.pop();
        prep_ior(fflush(fdTmp));
    END


    ANSI PRIMARY $file_size "file-size"                     ( fileid -- ud ior )
        fdTmp = (FILE *) SP.pop();
        slTmp = stat(FOpenName, &stat_buf);
        SP.push2(slTmp ? -1 : stat_buf.st_size);
        prep_ior(slTmp);
    END


    ANSI PRIMARY $$resize_file "resize-file"                ( ud fileid -- ior )
        fdTmp = (FILE *) SP.pop();
        cl2Tmp = SP.pop2();

        if(fflush(fdTmp)) {
            SP.push(errno);
            next;
        }

        slTmp = fileno(fdTmp);
        if(slTmp == -1) {
            SP.push(errno);
            next;
        }

        prep_ior(ftruncate(slTmp, cl2Tmp));
    END


    ANSI PRIMARY $read_file "read-file"                     ( c-addr u1 fileid -- u2 ior )
        fdTmp = (FILE *) SP.pop();
        clTmp = SP.pop();
        cpTmp = SP.cpPop();

        SP.push(0);     // nread  SP[2]
        SP.push(0);     // ior    SP[1]
        clTmp2 = 0;
        while(clTmp2 < clTmp) {
            clTmp2 += fread(cpTmp + clTmp2, 1, clTmp - clTmp2, fdTmp);

            if(clTmp2 < clTmp) {
                if(feof(fdTmp))
                    break;

                if(errno != EINTR) {
                    SP[1] = errno;
                    break;
                }
            }
        }

        SP[2] = clTmp2;
    END


    ANSI PRIMARY $write_file "write-file"                   ( c-addr u1 fileid -- ior )
        fdTmp = (FILE *) SP.pop();
        clTmp = SP.pop();
        cpTmp = SP.cpPop();

        SP.push(0);
        clTmp2 = 0;
        while(clTmp2 < clTmp) {
            clTmp2 += fwrite(cpTmp + clTmp2, 1, clTmp - clTmp2, fdTmp);

            if(clTmp2 < clTmp) {
                if(errno != EINTR) {
                    SP[1] = errno;
                    break;
                }
            }
        }
    END


    ANSI PRIMARY $read_line "read-line"                     ( c-addr u1 fileid -- u2 flag ior )
        fdTmp = (FILE *) SP.pop();
        clTmp = SP.pop();
        cpTmp = SP.cpPop();

        fprintf(stderr, "read-line *%tX[%d] from *%tX\n", cpTmp, clTmp, fdTmp);

        SP.push(0);     // u2   SP[3]
        SP.push(TRUE);  // flag SP[2]
        SP.push(0);     // ior  SP[1]

        while(SP[3] < clTmp) {
            slTmp = fgetc(fdTmp);
            if(slTmp == EOF) {
                if(feof(fdTmp)) {
                    if(SP[3] == 0)
                        SP[2] = FALSE;
                }
                else {
                    if(errno == EINTR)
                        continue;
                    SP[2] = FALSE;
                    SP[1] = errno;
                }
                break;
            }

            *cpTmp++ = (char) slTmp;
            ++SP[3];
        }
    END


    ANSI SECONDARY $write_line "write-line"                 ( c-addr u1 fileid -- ior )
        $write_file
        dup jmpnz(L0)
        cr              // any error from this gets ... slightly lost!

      L0:
    END


    //////////////////////////////////////////////////////////////////////
    // Object OPERATORS
    // NOTE: most of these assume GC cannot be triggered during their action
    // TODO: shift these to a separate Dictionary
    //
    PRIMARY op::check_arena                             ( C-addr -- )
        Allocator::CheckArena(SP.cpPop());
    END


    PRIMARY op::depth                                   ( -- u )
        SP.push(OS.depth());
    END


    PRIMARY op::drop                                    ( O: op -- )
        OS.pop().CDown();
    END


    PRIMARY op::dup                                     ( O: op -- op op )
        OS.inc();
        (OS[1] = OS[2]).CUp();
    END


    PRIMARY op::dup2                                    ( O: op -- op op op )
        OS.inc(2);
        OS[1] = OS[2] = OS[3];
        OS[1].CUp();
        OS[1].CUp();
    END


    PRIMARY op::swap                                    ( O: op1 op2 -- op2 op1 )
        opTmp = OS[1];
        OS[1] = OS[2];
        OS[2] = opTmp;
    END


    PRIMARY op::over                                    ( O: op1 op2 -- op1 op2 op1 )
        OS.inc();
        (OS[1] = OS[3]).CUp();
    END


    PRIMARY op::rrot                                    ( O: op1 op2 op3 -- op3 op1 op2 )
        opTmp = OS[1];
        OS[1] = OS[2];
        OS[2] = OS[3];
        OS[3] = opTmp;
    END


    PRIMARY op::rot                                     ( O: op1 op2 op3 -- op2 op3 op1 )
        opTmp = OS[3];
        OS[3] = OS[2];
        OS[2] = OS[1];
        OS[1] = opTmp;
    END


    PRIMARY op::over2                                   ( O: op1 op2 op3 -- op1 op2 op3 op1 )
        OS.inc();
        (OS[1] = OS[4]).CUp();
    END


    PRIMARY op::swap2                                   ( O: op1 op2 op3 -- op3 op2 op1 )
        opTmp = OS[1];
        OS[1] = OS[3];
        OS[3] = opTmp;
    END


    PRIMARY op::$add "+"                                ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::+ - not isInt");

        OS[2] += OS[1];
        OS.pop();
    END


    PRIMARY op::$sub "-"                                ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::- - not isInt");

        OS[2] -= OS[1];
        OS.pop();
    END


    PRIMARY op::$star "*"                               ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::* - not isInt");

        OS[2] *= OS[1];
        OS.pop();
    END


    PRIMARY op::$div "/"                                ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::/ - not isInt");

        OS[2] /= OS[1];
        OS.pop();
    END


    PRIMARY op::$mod "mod"                              ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::mod - not isInt");

        OS[2] %= OS[1];
        OS.pop();
    END


    PRIMARY op::$bit_and "and"                          ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::and - not isInt");

        OS[2] &= OS[1];
        OS.pop();
    END


    PRIMARY op::$bit_or "or"                            ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::or - not isInt");

        OS[2] |= OS[1];
        OS.pop();
    END


    PRIMARY op::$bit_xor "xor"                          ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::xor - not isInt");

        OS[2] ^= OS[1];
        OS.pop();
    END


    PRIMARY op::$bit_lshift "lshift"                    ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::lshift - not isInt");

        OS[2] <<= OS[1];
        OS.pop();
    END


    PRIMARY op::$bit_rshift "rshift"                    ( O: op1 op2 -- op3 )
        if(! OS[1].isInt() || ! OS[2].isInt())
            SPEWING(" Bad arguments to op::rshift - not isInt");

        OS[2] >>= OS[1];
        OS.pop();
    END


    PRIMARY op::$bit_lshifti "lshifti"                  ( O: op1 -- op2 ; u -- )
        if(! OS[1].isInt())
            SPEWING(" Bad argument to op::lshifti - not isInt");

        OS[1] <<= SP[1];
    END


    PRIMARY op::$bit_rshifti "rshifti"                  ( O: op1 -- op2 ; u -- )
        if(! OS[1].isInt())
            SPEWING(" Bad argument to op::rshifti - not isInt");

        OS[1] >>= SP[1];
    END


    PRIMARY op::negate                                  ( O: op1 -- op2 )
        if(! OS[1].isInt())
            SPEWING(" Bad argument to op::negate - not isInt");

        OS[1] = - OS[1];
    END


    PRIMARY op::invert                                  ( O: op1 -- op2 )
        if(! OS[1].isInt())
            SPEWING(" Bad argument to op::invert - not isInt");

        OS[1] = ~ OS[1];
    END


    PRIMARY op::$1plus "1+"                             ( O: op1 -- op2 )
        if(! OS[1].isInt())
            SPEWING(" Bad argument to op::1+ - not isInt");

        OS[1]++;
    END


    PRIMARY op::$1minus "1-"                            ( O: op1 -- op2 )
        if(! OS[1].isInt())
            SPEWING(" Bad argument to op::1- - not isInt");

        OS[1]--;
    END


    PRIMARY op::$2minus "2-"                            ( O: op1 -- op2 )
        if(! OS[1].isInt())
            SPEWING(" Bad argument to op::2- - not isInt");

        OS[1] -= opFromInt(-2);
    END


    PRIMARY op::$_minus_1 "-1"                          ( O: -- -1 )
        OS.push(opFromInt(-1));
    END


    PRIMARY op::0                                       ( O: -- 0 )
        OS.push(opFromInt(0));
    END


    PRIMARY op::1                                       ( O: -- 1 )
        OS.push(opFromInt(1));
    END


    PRIMARY op::2                                       ( O: -- 2 )
        OS.push(opFromInt(2));
    END


    PRIMARY op::isnil                                   ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.isNil());
        opTmp.CDown();
    END


    PRIMARY op::isref                                   ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(! opTmp.isNil() && opTmp.isRef());
        opTmp.CDown();
    END


    PRIMARY op::isint                                   ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.isInt());
        opTmp.CDown();
    END


    PRIMARY op::isqual                                  ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.isQual());
        opTmp.CDown();
    END


    PRIMARY op::isobj                                   ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.isObj());
        opTmp.CDown();
    END


    PRIMARY op::isdim                                   ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.isDim());
        opTmp.CDown();
    END


    PRIMARY op::isbin                                   ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.isBin());
        opTmp.CDown();
    END


    // PRIMARY op::isuni                                ( O: op -- ; -- u )
    //     opTmp = OS.pop();
    //     SP.push(opTmp.isUni());
    //     opTmp.CDown();
    // END


    PRIMARY op::object_class                            ( O: -- op )
        OS.push(OP::ObjectClass);
    END


    PRIMARY op::int_class                               ( O: -- op )
        OS.push(OP::IntClass);
    END


    PRIMARY op::qual_class                              ( O: -- op )
        OS.push(OP::QualClass);
    END


    PRIMARY op::nil_class                               ( O: -- op )
        OS.push(OP::NilClass);
    END


    PRIMARY op::nil                                     ( O: -- OP::NIL )
        OS.push(NIL);
    END


    PRIMARY op::int_from                                ( O: op -- ; -- n )
        opTmp = OS.pop();
        // TODO: do the right thing if it's not isInt
        SP.push(opTmp.isInt() ? opTmp.iFrom() : 0);
        opTmp.CDown();
    END


    PRIMARY op::from_int                                ( n -- ; O: -- op )
        OS.push(opFromInt(SP.pop()));
    END


    PRIMARY op::qual_new                                ( u -- ; O: -- oq )         // allocate an uninitialized managed string
        opTmp = OP::opQualNew(SP.pop());
        OS.push(opTmp);
    END


    PRIMARY op::qual_strcpy                             ( c-addr u -- ; O: -- oq )  // copy a C string into managed memory
        clTmp = SP.pop();
        cpTmp = SP.cpPop();
        OS.push(OP::opQualStrCpy(clTmp, cpTmp));
    END


    PRIMARY op::qual_strref                             ( c-addr u -- ; O: -- oq )  // allocate a qual referencing an unmanaged C string
        clTmp = SP.pop();
        cpTmp = SP.cpPop();
        OS.push(OP::opQualStrRef(clTmp, cpTmp));
    END


    PRIMARY op::qual_newsub                             ( n1 n2 -- ; O: oq1 -- oq2 )    // allocate a qual as a substr of another qual
        // 3      Word bsz, OP str, Word ofs
        // TODO: check isQual
        opTmp = OS.pop();
        clTmp2 = SP.pop();
        clTmp = SP.pop();
        OS.push(OP::opQualSub(clTmp, opTmp, clTmp2));
    END


    PRIMARY op::str_loc                                 ( O: op -- ; -- c-addr )
        OS.pop().strLoc();
    END


    PRIMARY op::str_len                                 ( O: op -- ; -- n )
        OS.pop().strLen();
    END


    PRIMARY op::object_new                              ( u u u -- ; O: op-class -- op )
        // OP opClass, Word align, Word szEa, Word nItems
        clTmp2 = SP.pop();
        clTmp  = SP.pop();

        opTmp = OS.pop();
        opTmp.CUp();

        opTmp = OP::opObjectNew(opTmp, SP.pop(), clTmp, clTmp2);
        opTmp.CUp();

        OS.push(opTmp);
    END

    // TODO: this is gonna be ugly!
    // op::array_new      OP opClass, Word align, Word szEa, Word dims, [Words bounds]


    PRIMARY op::dump                                    ( O: op -- ; -- )
        opTmp = OS.pop();
        opTmp.dump(MESSAGE_SILENT, false);
        opTmp.CDown();
    END


    PRIMARY op::class_of                                ( O: op - op-class )
        opTmp = OS.pop();
        OS.push(opTmp.classOf());
        opTmp.CDown();
        OS[1].CUp();
    END


    PRIMARY op::register_root                           ( O: op -- )
        // TODO: guard?
        OS.pop().registerRoot();
    END


    PRIMARY op::deregister_root                         ( O: op -- )
        // TODO: guard?
        OS.pop().deregisterRoot();
    END


    ANSI PRIMARY $op_to_sp "op>sp"                      ( O: op -- ; -- n )
        SP.push(OS.pop().IntPart());
    END


    ANSI PRIMARY $sp_to_op "sp>op"                      ( n -- ; O: -- op )
        OS.push(opRaw(SP.pop()));
    END


    PRIMARY -noheader $$op::assoc                       ( -- op-assoc )
        OS.push(opRaw(Cell(WA)));
    END


    PRIMARY $intern_symbol_strcpy ">#cpy"               ( c-addr u -- ; O: -- op-sym )
        clTmp = SP.pop();
        cpTmp = SP.cpPop();
        OS.push(OP::SymbolsSet.InternSymbolStrCpy(clTmp, cpTmp));
    END


    PRIMARY $intern_symbol_strref ">#ref"               ( c-addr u -- ; O: -- op-sym )
        clTmp = SP.pop();
        cpTmp = SP.cpPop();
        OS.push(OP::SymbolsSet.InternSymbolStrCpy(clTmp, cpTmp));
    END


    SECONDARY op::global                                ( "<spaces>name" -- / / / O: -- op-assoc )
        // registers a named variable in the GlobalsHash
        // acts like a normal TIL variable in that:
        //   1. the association OP can be safely stored in the dictionary because
        //      its count is held by the reference from the GlobalsHash
        //   2. accessing the global causes the association OP to be put on the OP stack
        //   3. a word is (to be written to) dereference the association,
        //      yielding only the object
        //   4. a word is (to be written to) store a new object in the association.

        // store 0 initially, then smash it with the association reference
        0 constant
        dwc($$op::assoc) $ca_store

        //
        // address of current (new) word - get the string address and length: c-addr u
        entry count
        $intern_symbol_strref
    END


    PRIMARY op::assoc_fetch "@"                         ( O: op-assoc -- op )
        // TODO: probably should be methods of the association class?
        opTmp = OS.pop();
        opTmp2 = opTmp.AssocGetVal();
        opTmp2.CUp();
        OS.push(opTmp2);
        opTmp.CDown();
    END


    PRIMARY op::assoc_store "!"                         ( O: op-assoc op -- )
        // TODO: probably should be methods of the association class?
        opTmp2 = OS.pop();
        opTmp = OS.pop();
        opTmp.AssocSetVal(opTmp2);
    END


    PRIMARY op::$eq "==="                               ( O: op1 op2 -- ; -- u )
        opTmp = OS.pop();
        opTmp2 = OS.pop();

        SP.push(opTmp == opTmp2);

        opTmp.CDown();
        opTmp2.CDown();
    END


    PRIMARY op::$ne "~==="                              ( O: op1 op2 -- ; -- u )
        opTmp = OS.pop();
        opTmp2 = OS.pop();

        SP.push(opTmp != opTmp2);

        opTmp.CDown();
        opTmp2.CDown();
    END


    PRIMARY op::bsz_data                                ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.bszData());
        opTmp.CDown();
    END


    PRIMARY op::wsz_data                                ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.wszData());
        opTmp.CDown();
    END


    PRIMARY op::limit_ptr                               ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.LimitPtr());
        opTmp.CDown();
    END


    PRIMARY op::limit_word                              ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.LimitWord());
        opTmp.CDown();
    END


    PRIMARY op::start_ptr                               ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.StartPtr());
        opTmp.CDown();
    END


    PRIMARY op::start_word                              ( O: op -- ; -- u )
        opTmp = OS.pop();
        SP.push(opTmp.StartWord());
        opTmp.CDown();
    END


    PRIMARY op::get_at                                  ( O: op1 -- op2 ; i -- )
        opTmp = OS.pop();
        opTmp2 = opTmp.opGetAt(SP.pop());
        opTmp2.CUp();
        opTmp.CDown();
        OS.push(opTmp2);
    END


    PRIMARY op::set_at                                  ( O: op1 op2 -- ; i -- )
        opTmp2 = OS.pop();
        opTmp = OS.pop();
        opTmp.opSetAt(SP.pop(), opTmp2);
        opTmp.CDown();
        opTmp2.CDown();
    END


    // getters and setters for:
    // CharAt
    // IntAt
    // Int16At
    // Int32At
    // Int64At
    // Float32At
    // Float64At
    // FloatLDAt



    //////////////////
    // Block words 7.6
    //
    // 1.1360      EVALUATE        Extend the semantics of 6.1.1360 EVALUATE
    // 1.1790      LOAD            ( i*x u -- j*x )
    // 2.1330      EMPTY-BUFFERS   ( -- )
    //
    // 2.2125      REFILL          ( -- flag )
    // Extend the execution semantics of 6.2.2125 REFILL
    //
    // 2.2190      SCR             ( -- a-addr )
    // 2.2280      THRU            ( i*x u1 u2 -- j*x )
    // 2.2535      \               Extend the semantics of 6.2.2535 \
    //             Compilation:    Perform the execution semantics given below.
    //             Execution:      ( ccc<eol>-- )


    ANSI PRIMARY block                                  ( u -- a-addr )
        cpTmp = BlockBuffer::Block(SP.pop());
        SP.cpPush(cpTmp);
    END


    ANSI PRIMARY buffer                                 ( u -- a-addr )
        cpTmp = BlockBuffer::Buffer(SP.pop());
        SP.cpPush(cpTmp);
    END


    ANSI PRIMARY flush                                  ( -- )
        BlockBuffer::flush_buffers();
    END


    ANSI PRIMARY $save_buffers "save-buffers"           ( -- )
        BlockBuffer::save_buffers();
    END


    ANSI PRIMARY $empty_buffers "empty-buffers"         ( -- )
        BlockBuffer::empty_buffers();
    END


    ANSI SECONDARY list                                 ( u -- )
        block

        16 0 $$do
      L1:
            dup 64 type cr
            64 $add
        loop(L1)

        drop
    END


    ANSI PRIMARY update                                 ( -- )
        BlockBuffer::update_current();
    END


    ANSI SECONDARY source                               ( -- c-addr u )
        blk $fetch $question_dup jmpnz(L1)
        $$linebuffer
        jmp(L0)

      L1:
        block 1024

      L0:
    END


    // forget - TODO: need to free any embedded strings!! this is a problem... wait for the GC version?
    PRIMARY -noheader $$inline
        do {
            LBofs = LBlen = 0;

            if(SourceID) {
                while((clTmp = getc(SourceID)) != EOF && clTmp != '\n')
                    if(LBlen < SIZE_LINEBUF)
                        LBsrc[LBlen++] = clTmp;
            }
            else {
                init_readline();

                // setting returns 0, the jump here returns nonzero.
                // thus - if a longjump happens, it will spin back and
                // re-prepare the setjmp once.
                if(LBownsRL)
                    while(sigsetjmp(sjbReadline, 1))
                    ;

                if(! no_ok)
                    putchar('\n');

                if(LBownsRL) {
                    inReadline = 1;
                    cpTmp = readline(NULL);
                    inReadline = 0;

                    if(cpTmp == NULL)
                        clTmp = EOF;
                    else {
                        while(LBlen < SIZE_LINEBUF && cpTmp[LBlen]) {
                            LBsrc[LBlen] = cpTmp[LBlen];
                            ++LBlen;
                        }

                        free(cpTmp);
                    }
                }
                else {
                    while((clTmp = getchar()) != EOF && clTmp != '\n')
                        if(LBlen < SIZE_LINEBUF)
                            LBsrc[LBlen++] = clTmp;
                }
            }

            // back-track trailing spaces which are rubbish
            while(LBlen > 0 && (LBsrc[LBlen - 1] == ' ' || LBsrc[LBlen - 1] == '\t'))
                --LBlen;
            LBsrc[LBlen] = '\0';

            // bail if EOF
            // TODO: a better action! let the caller decide
            if(LBlen == 0 && clTmp == EOF) {
                SP.push(FALSE);
                next;
            }

            if(LBownsRL && LBlen) {
                HIST_ENTRY *hp = history_get(history_length);
                if(! hp || strcmp(hp->line, LBsrc)) {
                    add_history(LBsrc);
                    if(LBhistFile[0])
                        int status = append_history(1, LBhistFile);
                }
            }
        } while(LBlen == 0);

        // blank-pad the input buffer
        slTmp = LBlen;
        while(slTmp < SIZE_LINEBUF)
            LBsrc[slTmp++] = ' ';
        LBsrc[slTmp] = '\0';
        SP.push(TRUE);
    END  -- $$inline


    ANSI SECONDARY refill
        $source_id $_minus_1 $eq jmpz(L1)
        // input source is a string, so fail
        0 jmp(L0)

      L1:
        // check if the input source is a file
        $source_id jmpnz(L3)    // read from the file

      L2:
        // check if the input source is a block
        blk $fetch jmpz(L3)

        // read the next block
        blk 1 $store_add
        blk $fetch block

        // TODO: test for failure to read and return false or true appropriately
        0 jmp(L0)

      L3:
        $$inline

      L0:
    END


    //      typical word structure                         ofs within Dictionary
    // length   Cell(11),                                   18  length of name 'the-word-yo'
    // name     Cell(DICT_STRING('t','h','e','-')),         19  word-packed letters of name
    //          Cell(DICT_STRING('w','o','r','d')),         20  .
    //          Cell(DICT_STRING('-','y','o',32)),          21  .
    // link     Cell(&Dictionary[9]),                       22  pointer to length Cell of previous word
    // codeword GOTO_ADR(dwc_CODE),                         23  code address pointer (goto offset from $$HEAD actually)
    // extra    ... optional secondary cells
    //          ... or allocated space
    // magic1   Cell(0x77777777),                   // optional magics to help decompiler - see Makefile: fixlabels.pl -s
    // magic2   Cell(0x77777777),
    // magic3   Cell(0x77777777),
    //
    // headerless words have no length, name or link because they can't be searched
    // if the -s option is supplied to fixlabels.pl, then headerless words DO get those things,
    // however the name is munged with a leading space to make them difficult to find.

    ANSI PRIMARY find                                   ( c-addr -- c-addr 0 | xt 1 | xt -1 )
        // search current vocab
        clpTmp = *vocpContext;              // dictionary to search

        clpTmp2 = CellPtr(SP[1]);
        SP.push(0);                         // assign 0 to assume failure
        while(clpTmp) {
            cl2Tmp = *clpTmp & ~ IMMEDIATE_BIT;             // get length: mask off the -immediate bit
            cpTmp = CharPtr(clpTmp + 1);                    // address of actual string

            // pre-calculate offset of link field - round up length of name to Cell boundary
            slTmp = (cl2Tmp + sizeof(Cell) - 1) / sizeof(Cell) * sizeof(Cell);

            // if lengths match and the string matches...
            if(*clpTmp2 == cl2Tmp && ! strncasecmp((char *) (clpTmp2 + 1), (char *) cpTmp, cl2Tmp)) {
                SP[2] = Cell(CellPtr(cpTmp + slTmp) + 1);   // return address of codeword - next cell after link
                SP[1] = *clpTmp & IMMEDIATE_BIT ? 1 : -1;   // mark success - 1=immediate, -1=compilable
                break;
            }

            clpTmp = CellPtr(*CellPtr(cpTmp + slTmp));      // follow the link and try again
        }
    END  -- find


    SECONDARY -noheader $search                         ( x-addr -- 0 | xt 1 )
        $immediate c0set                        // ensure Immediate is clear in preparation
        here find $question_dup jmpnz(L1)       // if found, return with success

        // not found in context vocab
        drop 0 jmp(L0)

      L1:
        // test if it's immediate or not, and set the marker
        dup 1 $eq jmpz(L0)
        $immediate c1set

      L0:
    END  -- $search


    SECONDARY -noheader $_search                        ( x-addr -- x-addr 1 | 0 )
        find jmpz(L1)

        // found - immediate or not immediate
        // mark success
        1
        jmp(L0)

      L1:
        // mark failure the loeliger way - no address on failure
        drop
        0

      L0:
    END  -- $_search


    PRIMARY -noheader $$_number                         ( c-addr u -- 0 | n 1 | nd 2 | 3 ; F: -- | | | f )

# define LEADING_SIGN       0x01
# define EXPONENT_SIGN      0x02
# define CANT_FLOAT         0x04
# define CANT_NUMBER        0x08
# define SEEN_DIGITS        0x10

        // state flags encoded in clTmp:
        //   0x01 - seen leading sign '-'
        //   0x02 - seen exponent sign '-'
        //   0x04 - seen a hex digit so can't be a float (importent when base > 10)
        //   0x08 - seen a digit over base so can't be an integer
        //   0x10 - actually seen some digits either side of the optional dot

        // variables:
        //   clTmp   length of source string
        //   cpTmp   progressing pointer into string
        //   cTmp    working character
        //
        //   clTmp2  state
        //   sl2Tmp  digital accumulator
        //   sl2Tmp2 digital accumulator assuming base 10 (in case it's floaty)
        //   fLDTmp  floaty accumulator
        //   slTmp   number of digits seen after decimal place

        clTmp = SP.pop();                   // length
        cpTmp = SP.cpPop();                 // address of string

        if(clTmp == 0)      // instant fail?
            goto FAIL;

        clTmp2 = 0;
        sl2Tmp = 0;
        sl2Tmp2 = 0;

        if(*cpTmp == '-') {
            clTmp2 |= LEADING_SIGN;
            --clTmp;
            ++cpTmp;
        }
        else if(*cpTmp == '+') {
            --clTmp;
            ++cpTmp;
        }

        // collect leading digits
        while(clTmp > 0) {
            // convert the character to a possible numeric
            cTmp = *cpTmp;

            if('0' <= cTmp && cTmp <= '9')
                cTmp -= '0';
            else if(Base > 10 && 'a' <= cTmp && cTmp < 'a' + Base - 10)
                cTmp -= 'a' - 10;
            else if(Base > 10 && 'A' <= cTmp && cTmp < 'A' + Base - 10)
                cTmp -= 'A' - 10;
            else
                break;
            --clTmp;
            ++cpTmp;

            if(cTmp >= 10)
                clTmp2 |= CANT_FLOAT;   // seen hex or worse

            if(cTmp >= Base)
                clTmp2 |= CANT_NUMBER;  // might still be legal float

            clTmp2 |= SEEN_DIGITS;              // flip to state 1 - seen a digit
            sl2Tmp = sl2Tmp * Base + cTmp;
            sl2Tmp2 = sl2Tmp2 * 10 + cTmp;
        }

        if((clTmp2 & CANT_FLOAT) && (clTmp2 & CANT_NUMBER))
            goto FAIL;

        if(clTmp > 0 && *cpTmp == '.') {
            // if not reading decimal, must be finished now otherwise it's an error
            // note: trailing dot means it's a double-cell
            // note also: if the number appears to be all decimals,
            // it may only be a legal float unless CANT_FLOAT

            ++cpTmp;
            --clTmp;
            if(clTmp == 0) {
                if((clTmp2 & CANT_NUMBER) || ! (clTmp2 & SEEN_DIGITS))
                    goto FAIL;

                // can-number, and have seen digits,
                // so a trailing dot at the end means we're on a double cell
                if(clTmp2 & LEADING_SIGN)
                    sl2Tmp = -sl2Tmp;
                SP.push2(sl2Tmp);
                SP.push(2);         // indicates a double cell
                next;
            }

            // seen a dot but not finished - can only be a float
            if(clTmp2 & CANT_FLOAT)
                // unless it can't be a float...
                goto FAIL;

            // now collect fractional digits
            fLDTmp = sl2Tmp2;   // stash integral part collected so far
            sl2Tmp2 = 0;        // reset accumulator to collect fraction
            slTmp = 0;          // number of digits seen after dot

            while(clTmp > 0) {
                cTmp = *cpTmp;
                if(cTmp < '0' || '9' < cTmp)
                    break;
                cTmp -= '0';
                --clTmp;
                ++cpTmp;

                clTmp2 |= SEEN_DIGITS;             // flip to state 1 - seen a digit
                sl2Tmp2 = sl2Tmp2 * 10 + cTmp;
                ++slTmp;
            }

            // if we've seen no digits either side of the dot, definitely not a number
            if(! (clTmp2 & SEEN_DIGITS))
                goto FAIL;

            if(slTmp)   // had a fractional part? add it in
                fLDTmp += FloatLD(sl2Tmp2) / exp10l(slTmp);

            // time to collect an exponent?
            if(clTmp > 0 && (*cpTmp == 'e' || *cpTmp == 'E')) {
                --clTmp;
                ++cpTmp;

                if(clTmp > 0)
                    if(*cpTmp == '-') {
                        clTmp2 |= EXPONENT_SIGN;
                        --clTmp;
                        ++cpTmp;
                    }
                    else if(*cpTmp == '+') {
                        --clTmp;
                        ++cpTmp;
                    }

                if(clTmp == 0)
                    goto FAIL;

                // collect exponent and process it
                slTmp = 0;
                while(clTmp > 0) {
                    cTmp = *cpTmp;
                    if(cTmp < '0' || '9' < cTmp)
                        break;
                    cTmp -= '0';
                    --clTmp;
                    ++cpTmp;
                    slTmp = slTmp * 10 + cTmp;
                }

                if(clTmp2 & EXPONENT_SIGN)
                    slTmp = -slTmp;

                // apply the exponent
                fLDTmp *= exp10l(slTmp);
            }

            if(clTmp > 0)
                goto FAIL;

            if(clTmp2 & LEADING_SIGN)
                fLDTmp = -fLDTmp;

            SP.push(3);
            FP.push(fLDTmp);
            next;
        }

        // must be an ordinary number
        // return a cell if the string has run out
        if(clTmp == 0) {
            slTmp = clTmp2 & LEADING_SIGN ? -sl2Tmp : sl2Tmp;
            SP.push(slTmp);
            SP.push(1);
            next;
        }
        // otherwise return failure

      FAIL:             // it's a state machine. shut up...
        SP.push(0);
        next;
    END  -- $$_number


    SECONDARY -noheader $$number
        here
        $cell_plus
        here
        $fetch
        $$_number
    END


    ANSI SECONDARY $to_float ">float"
        $$_number dup jmpz(LEND)

        $1minus dup jmpz(LCELL)
        $1minus jmpz(LCELL2)
        jmp(LFLOATY)

      LCELL:
        drop
        $s_to_d

      LCELL2:
        $d_to_f

      LFLOATY:
        1

      LEND:
    END


    SECONDARY -noheader $number
        $$number $question_dup jmpz(LFAIL)
        state $cfetch jmpz(LINTERP)

        $1minus dup jmpz(LCELL)
        $1minus jmpz(LCELL2)

      LFLOAT:
        adr($$fliteral) $comma
        $fcomma
        jmp(LWIN)

      LCELL2:
        adr($$2literal) $comma
        $2comma
        jmp(LWIN)

      LCELL:
        drop
        adr($$literal) $comma
        $comma
        jmp(LWIN)

      LINTERP:
        drop

      LWIN:
        1 jmp(LEND)

      LFAIL:
        0

      LEND:
    END  -- $number


    PRIMARY -noheader $$search_failed
        clpTmp2 = DP;

        if(! *clpTmp2) {                 // no token left? woo! execute will loop
            SP.cpPush(CharPtr(no_ok ? MESSAGE_SILENT : MESSAGE_OK));
            next;
        }

        WA = CellPtr(MESSAGE_QUE);

        if(! isatty0 && ! SourceID) {       // reading from stdin?
            printf("Cannot find %.*s\n", *clpTmp2, clpTmp2 + 1);
            exit(1);
        }

    $PATCH:
        if(State) {     // in compiling?
            clpTmp2 = *vocpCurrent;
            cpTmp = CharPtr((Cell(clpTmp2) + (*clpTmp2 & ~ IMMEDIATE_BIT) + sizeof(Cell) + sizeof(Cell) - 1) & ~ (sizeof(Cell) - 1));

            DP = clpTmp2;
            *vocpCurrent = *CellPtrPtr(cpTmp);
            cleanLocals();
        }

        goto $ABORT;
    END  -- $$search_failed


    PRIMARY -noheader $$stack
        // for those ohhhhh crap moments
        if(SP.underflow()) SPEWING(MESSAGE_USTACK);
        if(SP.overflow())  SPEWING(MESSAGE_OSTACK);
        if(FP.underflow()) SPEWING(MESSAGE_FUSTACK);
        if(FP.overflow())  SPEWING(MESSAGE_FOSTACK);
        if(OS.underflow()) SPEWING(MESSAGE_OUSTACK);
        if(OS.overflow())  SPEWING(MESSAGE_OOSTACK);
    END  -- $$stack


    ANSI SECONDARY $tick "'"                            ( "<spaces>name" -- xt )
        bl $$token $search jmpnz(L1)
        $$fail
      L1:
    END


    ANSI SECONDARY char                                 ( "<spaces>name" -- char )
        bl $$token
        here $cell_plus $cfetch
    END


    SECONDARY -noheader $execute
        // get and set Immediate back to zero
        $immediate $cfetch not
        state $cfetch $and
        $immediate c0set
        jmpnz(L1)

        // not equal, just execute and check stack
        execute $$stack jmp(L0)

      L1:
        $comma

      L0:
    END  -- $execute


    // MAIN PROGRAM - outer interpreter
    SECONDARY -noheader $$outer
      L1:
        $source_id jmpz(PROMPT)
        drop jmp(LINE)

      PROMPT:
        csz_type

      LINE:
        refill jmpnz(L2)
        bye

      L2:
        // loop to read tokens, find and then execute or compile
        bl $$token

        $glocal jmpnz(L2)
        $search jmpnz(L3)
        $number jmpnz(L2)               // test to see if it's a number
        $$search_failed jmp(L1)         // failed to find a word or a number

      L3:
        $execute jmp(L2)
    END  -- $$outer


    PRIMARY -noheader $$push_input_source
        RS.push(CellPtrPtr(SourceID));
        RS.push(CellPtrPtr(Blk));
        RS.push(CellPtrPtr(LBsrc));
        RS.push(CellPtrPtr(LBofs));
        RS.push(CellPtrPtr(LBlen));
    END

    PRIMARY -noheader $$pop_input_source
        LBlen    = Cell(RS.pop());
        LBofs    = Cell(RS.pop());
        LBsrc    = CharPtr(RS.pop());
        Blk      = Cell(RS.pop());
        SourceID = (FILE *) RS.pop();
    END


    PRIMARY -noheader $$prep_evaluate
        SourceID = (FILE *) -1;
        LBlen = SP.pop();
        LBsrc = SP.cpPop();
        LBofs = 0;
        Blk = 0;
    END


    PRIMARY -noheader $$prep_load
        SourceID = (FILE *) -1;
        LBlen = SP.pop();
        LBsrc = SP.cpPop();
        LBofs = 0;
        Blk = SP.pop();
    END


    ANSI SECONDARY evaluate                             ( i*x c-addr u -- j*x )
        $$push_input_source
        $$prep_evaluate

      L2:
        bl $$token
        here $fetch jmpz(L4)            // test for nothing left
        $search jmpnz(L3)
        $number jmpnz(L2)               // test to see if it's a number

        $$pop_input_source
        $$search_failed                 // failed to find a word or a number

      L3:
        $execute jmp(L2)

      L4:
        $$pop_input_source
    END


    ANSI SECONDARY load                                 ( i*x u -- j*x )
        $$push_input_source
        dup block 1024
        $$prep_load

      L2:
        bl $$token
        here $fetch jmpz(L4)            // test for nothing left
        $search jmpnz(L3)
        $number jmpnz(L2)               // test to see if it's a number

        $$pop_input_source
        $$search_failed                 // failed to find a word or a number

      L3:
        $execute jmp(L2)

      L4:
        $$pop_input_source
    END


    ANSI SECONDARY thru                                 ( i*x u1 u2 -- j*x )
        2dup $gt jmpz(L1)
        2drop jmp(L0)

      L1:
        $1plus swap
        $$do
      L2:
            i load
            loop(L2)

      L0:
    END


    ANSI SECONDARY value                                ( x "<spaces>name" -- / / / -- x )
        constant
        dwc($$value) $ca_store
    END


    ANSI SECONDARY -immediate to                        ( x "<spaces>name" -- / "<spaces>name" -- / / x -- )
        bl $$token

        // bail out if failed to get a token
        here $fetch jmpnz(L1)
        $$fail

      L1:
        $slocal jmpnz(L0)
        here $_search jmpnz(L2)    // if found, continue
        $$fail

      L2:
        // find the named beasty - DEATH will occur if it's not a "value"
        // check if the token is a $$value thingy

        dup $fetch
        dwc($$value) $eq
        jmpnz(L3)
        $$fail

      L3:
        // if running in interpretive state, store now
        state $cfetch
        jmpnz(L4)

        $cell_plus
        $store
        jmp(L0)

      L4:
        // if running in compile state, emit threads to store
        adr($$literal) $comma
        $cell_plus $comma
        adr($store) $comma

      L0:
    END  -- to


    PRIMARY handler
        SP.clpPush(&exception_frame);
    END


    // TODO: need to make it available in immediate state AND source-reading mode
    ANSI PRIMARY quit                                   ( -- ; R: j*x -- )
        Quitting = 1;
        goto $PATCH;
    END


    SECONDARY $$_catch                    ( xt -- exception# | 0 ) // return addr on stack
        $sp_fetch $to_r             // ( xt )   save data stack pointer
        handler $fetch $to_r        // ( xt )   and previous handler
        $rs_fetch handler $store    // ( xt )   set current handler
        execute                     // ( )      execute returns if no THROW
        $r_from handler $store      // ( )      restore previous handler
        $r_from drop                // ( )      discard saved stack ptr
        0                           // ( 0 )    normal completion
    END


    ANSI SECONDARY catch                            ( xt -- exception# | 0 )
        // TODO: need to capture the OP stack too
        $fp_fetch $to_r
        $$_catch
        $r_from over jmpz(L1)
        $fp_store jmp(L0)
      L1:
        drop
      L0:
    END


    ANSI SECONDARY throw                            ( ??? exception# -- ??? exception# )
        $question_dup jmpz(L0)  // ( exc# )        0 THROW is no-op

        // handler $fetch $_0eq drop jmpz(L1)
        // quit                            // if no catch handler installed

      L1:
        handler $fetch $rs_store        // ( exc# )     restore prev return stack
        $r_from handler $store          // ( exc# )     restore prev handler
        $r_from swap $to_r              // ( saved-sp ) exc# on return stack
        $sp_store drop $r_from          // ( exc# )     restore stack
        //  Return to the caller of CATCH because return
        //  stack is restored to the state that existed
        //  when CATCH began execution

      L0:
    END


    ANSI PRIMARY -immediate abort                       ( i*x -- ; R : j*x -- )
        Quitting = 1;
        SP.clear();
        goto $PATCH;
    END


    ANSI SECONDARY -immediate $paren "("                ( "ccc<paren>" -- / "ccc<paren>" -- / / )       // inline comment
        ')' $$token
        // discard token by ignoring it
    END


    ANSI SECONDARY -immediate $backslash "\\"           ( "ccc<eol>" -- )
        '\n' $$token
    END


    // this one for MY commenting habits
    SECONDARY -immediate $back_hash1 "\\#"              ( "ccc<eol>" -- )
        '\n' $$token
    END


    // this one for MY commenting habits
    SECONDARY -immediate $back_hash2 "\\##"             ( "ccc<eol>" -- )
        '\n' $$token
    END


    // this one for MY commenting habits
    SECONDARY -immediate $back_hash3 "\\###"            ( "ccc<eol>" -- )
        '\n' $$token
    END


    ANSI PRIMARY $right_bracket "]"                     ( UNDEF / / / -- )
        State = 1;
    END


    ANSI PRIMARY $time_and_date "time&date"             ( -- +n1 +n2 +n3 +n4 +n5 +n6 )
        (void) time(&tmt);
        (void) localtime_r(&tmt, &tms);

        SP.push(tms.tm_sec);
        SP.push(tms.tm_min);
        SP.push(tms.tm_hour);
        SP.push(tms.tm_mday);
        SP.push(tms.tm_mon + 1);
        SP.push(tms.tm_year + 1900);
    END


    ANSI PRIMARY $dash_trailing "-trailing"             ( c-addr u1 -- c-addr u2 )
        slTmp = SP.pop();
        cpTmp = CharPtr(SP[1]);
        while(slTmp > 0 && cpTmp[slTmp - 1] == ' ')
            --slTmp;
        SP.push(slTmp);
    END


    ANSI PRIMARY $slash_string "/string"                ( c-addr1 u1 n -- c-addr2 u2 )
        slTmp = SP.pop();
        if(slTmp > sCell(SP[1]))
            slTmp = sCell(SP[1]);
        SP[1] -= slTmp;
        SP[2] += slTmp;
    END


    ANSI PRIMARY cmove                                  ( c-addr1 c-addr2 u -- )
        slTmp = SP.pop();
        cpTmp2 = SP.cpPop();
        cpTmp  = SP.cpPop();

        while(slTmp-- > 0)
            *cpTmp2++ = *cpTmp++;
    END


    ANSI PRIMARY $cmove_up "cmove>"                     ( c-addr1 c-addr2 u -- )
        slTmp = SP.pop();
        cpTmp2 = SP.cpPop() + slTmp;
        cpTmp  = SP.cpPop() + slTmp;

        while(slTmp-- > 0)
            *--cpTmp2 = *--cpTmp;
    END


    ANSI PRIMARY compare                                ( c-addr1 u1 c-addr2 u2 -- n )
        clTmp2 = SP.pop();
        cpTmp2 = SP.cpPop();
        clTmp = SP.pop();
        cpTmp = SP.cpPop();

        slTmp = 0;
        while(clTmp > 0 && clTmp2 > 0) {
            if(*cpTmp < *cpTmp2) {
                slTmp = -1;
                break;
            }

            if(*cpTmp > *cpTmp2) {
                slTmp = 1;
                break;
            }

            --clTmp; --clTmp2;
            ++cpTmp; ++cpTmp2;
        }

        if(slTmp == 0) {
            if(clTmp < clTmp2)
                slTmp = -1;
            else if(clTmp > clTmp2)
                slTmp = 1;
        }

        SP.push(slTmp);
    END


    ANSI PRIMARY search                                 ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
        clTmp2 = SP.pop();
        cpTmp2 = SP.cpPop();
        clTmp = SP[1];
        cpTmp = CharPtr(SP[2]);

        SP.push(FALSE);     // assume failure
        for(slTmp = 0; sCell(clTmp2) + slTmp < sCell(clTmp); ++slTmp) {
            for(slTmp2 = 0; slTmp2 < sCell(clTmp2); ++slTmp2)
                if(cpTmp[slTmp + slTmp2] != cpTmp2[slTmp2])
                    break;

            if(slTmp2 == sCell(clTmp2)) {
                SP[1] = TRUE;         // success
                SP[2] -= slTmp;
                SP[3] += slTmp;
                break;
            }
        }
    END


    ANSI PRIMARY blank                                  ( c-addr u -- )
        slTmp = SP.pop();
        cpTmp = SP.cpPop();

        while(slTmp-- > 0)
            *cpTmp++ = ' ';
    END


    // Programming-Tools words 15.6
    // -----------------------
    // 2.0470      ;CODE       Interpretation: (UNDEFINED)
    //             Compilation:        ( C: colon-sys -- )
    //             Run-time:   ( -- ; R: nest-sys -- )
    //             name Execution:     ( i*x -- j*x )
    //
    // 2.0740      ASSEMBLER                   ( -- )
    //
    // 2.0930      CODE                        ( "<spaces>name" -- )
    //             name Execution:     ( i*x -- j*x )
    //
    // 2.1300      EDITOR                      ( -- )
    // 2.1580      FORGET                      ( "<spaces>name" -- )
    // 2.2250      STATE                       ( -- a-addr )
    //
    // 2.2531      [ELSE]      Compilation: Perform the execution semantics given below.
    //             Execution:  ( "<spaces>name" ... -- )
    //
    // 2.2532      [IF]        Compilation: Perform the execution semantics given below.
    //             Execution:  ( flag | flag "<spaces>name" ... -- )
    //
    // 2.2533      [THEN]      Compilation: Perform the execution semantics given below.
    //             Execution:  ( -- )


    PRIMARY $$see ".see"                                ( xt -- )           // roughly dump a dictionary entry
        clpTmp = SP.clpPop();

        clpTmp2 = nameOfXT(specs, Dictionary, CellPtr(&clpTmp));
        if(clpTmp2)
            printf(": %-.*s", *clpTmp2 & ~ IMMEDIATE_BIT, clpTmp2 + 1);
        else {
            printf(": *%d", clpTmp);
        }

        // a bunch of codeword values are magical
        if(*clpTmp == GOTO_ADR($COLON)) {
            // printf(" ( SECONDARY )\n");
            // printf("    $colon ==  %p\n", CODE_ADDRESS($$scolon));
            // printf("    Dictionary: %p %p\n", CharPtr(Dictionary), CharPtr(DP));

            slTmp = 0;
            // TODO: WRONG! $$scolon may be embedded by EXIT or other words. Need a better loop guard
            while(*++clpTmp != Cell(CODE_ADDRESS($$scolon)) && *clpTmp != Cell(CODE_ADDRESS($$lscolon))) {
                // if(++slTmp >= 50) break;
                // printf(" [%d]", *clpTmp);

                // turn *clpTmp into the name of the word - if it can be found
                // depends on $opt_s being set; if not set, a heuristic search back for a name is on the cards
                slTmp2 = 1;
                if(Dictionary <= CellPtr(*clpTmp) && CellPtr(*clpTmp) < DP) {
                    clpTmp2 = nameOfXT(specs, Dictionary, clpTmp);
                    if(*clpTmp == Cell(CODE_ADDRESS($$literal))) {
                        ++clpTmp;
                        if(clpTmp2 = nameOfXT(specs, Dictionary, clpTmp))
                            printf(" ' %-.*s", *clpTmp2 & ~ IMMEDIATE_BIT, clpTmp2 + 1);
                        else
                            printf(" %d", *clpTmp);
                    }
                    else if(*clpTmp == Cell(CODE_ADDRESS($$do)))
                        printf(" do");

                    else if(*clpTmp == Cell(CODE_ADDRESS($$loop))
                         || *clpTmp == Cell(CODE_ADDRESS($$_add_loop))
                         || *clpTmp == Cell(CODE_ADDRESS($$jmp))
                         || *clpTmp == Cell(CODE_ADDRESS($$jmpnz))
                         || *clpTmp == Cell(CODE_ADDRESS($$jmpz))
                         || *clpTmp == Cell(CODE_ADDRESS($$question_do))
                         || *clpTmp == Cell(CODE_ADDRESS($$leave))
                    )
                        printf(" %-.*s(%d)", (*clpTmp2 & ~ IMMEDIATE_BIT) - 1, CharPtr(clpTmp2 + 1) + 1, *++clpTmp);
                    else {
                        slTmp2 = 0;
                        if(clpTmp2) {
                            slTmp2 = 1;
                            printf(" %-.*s", *clpTmp2 & ~ IMMEDIATE_BIT, clpTmp2 + 1);
                        }
                    }
                }

                if(slTmp2 == 0)
                    printf(" *%d", *clpTmp);
            }
            printf(" ;\n");
            next;
        }

        if(*clpTmp == GOTO_ADR(dwc_$$create))
            printf(" create");
        else if(*clpTmp == GOTO_ADR(dwc_$$variable))
            printf(" variable");
        else if(*clpTmp == GOTO_ADR(dwc_$$2variable))
            printf(" 2variable");
        else if(*clpTmp == GOTO_ADR(dwc_$$fvariable))
            printf(" fvariable");
        else if(*clpTmp == GOTO_ADR(dwc_$$value))
            printf(" value");
        else if(*clpTmp == GOTO_ADR(dwc_$$does))
            printf(" does");
        else if(*clpTmp == GOTO_ADR(dwc_constant))
            printf(" constant");
        else if(*clpTmp == GOTO_ADR(dwc_2constant))
            printf(" 2constant");
        else if(*clpTmp == GOTO_ADR(dwc_fconstant))
            printf(" fconstant");
        else
            printf(" PRIMARY");

        printf("\n");
    END  -- $$see


    ANSI SECONDARY see                                  ( "<spaces>name" -- )           // roughly dump a dictionary entry
        bl $$token $search jmpnz(L1)
        $$fail

      L1:
        $$see
    END


    PRIMARY -noheader _register_regions
        if(nRegions == 0) {
            // TODO: prove these are still in order with all the shuffling that's gone on since the science was invented
            // main focus: the tailing of one code block assumes it is followed by a specific code block. If they have moved...
            registerRegion("Base",          CharPtr(&Base),            sizeof(Base));
            registerRegion("State",         CharPtr(&State),           sizeof(State));
            registerRegion("Immediate",     CharPtr(&Immediate),       sizeof(Immediate));
            registerRegion("Quitting",      CharPtr(&Quitting),        sizeof(Quitting));
            registerRegion("vocpContext",   CharPtr(&vocpContext),     sizeof(vocpContext));
            registerRegion("vocpCurrent",   CharPtr(&vocpCurrent),     sizeof(vocpCurrent));
            registerRegion("voc_root",      CharPtr(&voc_root),        sizeof(voc_root));

            registerRegion("$$HEAD",        CharPtr(&&$$HEAD),         sCell(&&$COLON)         - sCell(&&$$HEAD));
            registerRegion("$COLON",        CharPtr(&&$COLON),         sCell(&&dwc_$$scolon)   - sCell(&&$COLON));
            // TODO: squeeze lcolon into here somehow

            registerRegion("dwc_$$scolon",  CharPtr(&&dwc_$$scolon),   sCell(&&$NEXT)          - sCell(&&dwc_$$scolon));

            registerRegion("$NEXT",         CharPtr(&&$NEXT),          sCell(&&$RUN)           - sCell(&&$NEXT));
            registerRegion("$RUN",          CharPtr(&&$RUN),           sCell(&&dwc_$$jmp)      - sCell(&&$RUN));
            registerRegion("CORE",          CharPtr(&&dwc_$$jmp),      sCell(&&$PREP_CORE)     - sCell(&&dwc_$$jmp));
            registerRegion("PREP_CORE",     CharPtr(&&$PREP_CORE),     sCell(&&$START)         - sCell(&&$PREP_CORE));

            registerRegion("buffers",       CharPtr(BlockBuffer::bufs), sizeof(BlockBuffer::bufs[NUM_BLK_BUFFERS]));
            registerRegion("LineBuffer",    CharPtr(LineBuffer),       sizeof(LineBuffer));
            registerRegion("PadBuffer",     CharPtr(PadBuffer),        sizeof(PadBuffer));
            registerRegion("PnoBuffer",     CharPtr(&PnoBuffer),       sizeof(PnoBuffer));

            registerRegion("Dictionary",    CharPtr(Dictionary),       sizeof(Dictionary),      CODE_ADDRESS($$see)),
            registerRegion("RS",            CharPtr(&RS),              sizeof(RS));
            registerRegion("SP",            CharPtr(&SP),              sizeof(SP));
            registerRegion("FP",            CharPtr(&FP),              sizeof(FP));
            registerRegion("OS",            CharPtr(&OS),              sizeof(OS));

            registerRegion("IP",            CharPtr(&IP),              sizeof(IP));
            registerRegion("WA",            CharPtr(&WA),              sizeof(WA));
            registerRegion("RS",            CharPtr(&RS),              sizeof(RS));
            registerRegion("SP",            CharPtr(&SP),              sizeof(SP));
            registerRegion("CA",            CharPtr(&CA),              sizeof(CA));
            registerRegion("DP",            CharPtr(&DP),              sizeof(DP));

            registerRegion("MESSAGE_START",     MESSAGE_START,          sizeof(MESSAGE_START));
            registerRegion("MESSAGE_RESTART",   MESSAGE_RESTART,        sizeof(MESSAGE_RESTART));
            registerRegion("MESSAGE_OK",        MESSAGE_OK,             sizeof(MESSAGE_OK));
            registerRegion("MESSAGE_QUE",       MESSAGE_QUE,            sizeof(MESSAGE_QUE));
            registerRegion("MESSAGE_USTACK",    MESSAGE_USTACK,         sizeof(MESSAGE_USTACK));
            registerRegion("MESSAGE_OSTACK",    MESSAGE_OSTACK,         sizeof(MESSAGE_OSTACK));
        }
    END


    PRIMARY -noheader $$what                            ( x -- )
        clpTmp = SP.clpPop();

        // first try to find it inside a region
        // if not found inside a region, find the closest region

        if(clpTmp == NULL) {
            printf("item is 0 or NULL\n");
            next;
        }

        {
            MemRegion::Ptr mrp = MemRegion::Ptr(bsearch(clpTmp, regions, nRegions, sizeof(MemRegion), matchRegion));
            // TODO: try to reverse-engineer the pointer to a name

            if(! mrp)
                printf("*%tX is not in a known region\n", clpTmp);
            else {
                if(mrp->handler) {
                    SP.clpPush(clpTmp);
                    WA = mrp->handler;
                    goto $RUN;
                }
                else {
                    printf("*%tX is in the %s region\n", clpTmp, mrp->cpName);
                }
            }
        }
    END


    SECONDARY $what "what?"
        _register_regions
        $$what
    END


    // PRIMARY show_regions
    //     showRegions();
    // END


    PRIMARY $$words                                     ( addr1 -- addr1 )              // list a dictionary
        clpTmp = SP.clpPop();       // address of dictionary to list

        while(clpTmp) {
            clpTmp2 = CellPtr(clpTmp);                      // address of length word
            clTmp2 = *clpTmp2 & ~ IMMEDIATE_BIT;            // get length: mask off the -immediate bit
            cpTmp = CharPtr(clpTmp + 1);                    // address of actual string

            // pre-calculate address of link field - round up length of name to Cell boundary
            clpTmp = CellPtr(cpTmp + (clTmp2 + sizeof(Cell) - 1) / sizeof(Cell) * sizeof(Cell));

            // if lengths match and the string matches...
            printf(" %-.*s", clTmp2, (char *) cpTmp);

            clpTmp = CellPtr(*clpTmp);          // follow the link and try again
        }

        printf("\n");
    END


    ANSI SECONDARY words                                ( -- )                      // list context dictionary
        context $fetch $fetch $$words
    END



    //////////////////////////////////////////////////////////////////
    // compiler immediate words start here, along with the work-horses
    // laid down by the compiler, which are characteristically NOT -immediate.
    //

    SECONDARY -noheader $jmp_comma
        $comma
        here
    END


    ANSI SECONDARY -immediate ahead                     ( UNDEF / C: -- orig / / -- )
        adr($$jmp) $jmp_comma
        0 $comma
    END


    SECONDARY -immediate aheadz                         ( UNDEF / C: -- orig / / -- )
        adr($$jmpz) $jmp_comma
        0 $comma
    END


    SECONDARY -immediate aheadnz                        ( UNDEF / C: -- orig / / -- )
        adr($$jmpnz) $jmp_comma
        0 $comma
    END


    SECONDARY -immediate $cs_pick "cs-pick"             ( UNDEF / C: nu .. n1 n0 u -- nu .. n1 n0 nu; u -- / / -- )
        pick
    END


    SECONDARY -immediate $cs_roll "cs-roll"             ( UNDEF / C: nu .. n1 n0 u -- nu-1 .. n0 nu; u -- / / -- )
        roll
    END


    SECONDARY -noheader $end_comma
        $jmp_comma
        $sub
        1 cells $div
        $comma
    END


    ANSI PRIMARY -immediate $left_bracket "["           ( UNDEF / / / -- )
        State = 0;
    END


    ANSI PRIMARY -noheader $nlocals
        SP.push(nLocals);
    END


    ANSI SECONDARY -immediate exit                      ( UNDEF / / / -- ; R: nest-sys -- )
        $nlocals
        jmpz(L1)

        // wrap up any activity needed to support locals
        adr($$lscolon) $comma
        $clean_locals
        jmp(L0)

      L1:
        adr($$scolon) $comma

      L0:
    END


    ANSI SECONDARY -immediate $scolon ";"               ( UNDEF / C: colon-sys -- / / -- ; R: nest-sys -- )
        exit
        state c0set
    END


    ANSI SECONDARY -immediate then                      ( UNDEF / C: orig -- / / -- )
        here
        over $sub 1 cells $div
        swap $store
    END


    ANSI SECONDARY -immediate else                      ( UNDEF / C: orig1 -- orig2 / / -- )
        ahead
        swap then
    END


    ANSI SECONDARY -immediate if                        ( UNDEF / C: -- orig / / x -- )
        aheadz
    END


    SECONDARY -immediate ifn                            ( UNDEF / C: -- orig / / x -- )
        aheadnz
    END


    ANSI SECONDARY -immediate begin                     ( UNDEF / C: -- dest / / -- )
        here
    END


    ANSI SECONDARY -immediate again                     ( UNDEF / C: dest -- / / -- )
        adr($$jmp) $end_comma
    END


    ANSI SECONDARY -immediate until                     ( UNDEF / C: dest -- / / x -- )
        adr($$jmpz) $end_comma
    END


    ANSI SECONDARY -immediate while                     ( UNDEF / C: dest -- orig dest / / x -- )
        aheadz
        swap                // NOTE: this swap MAY have to be at the start of REPEAT rather than here at the end of WHILE
    END


    ANSI SECONDARY -immediate repeat                    ( UNDEF / C: orig dest -- / / -- )
        adr($$jmp) $end_comma
        then
    END


    PRIMARY -noheader $get_leave_link                   ( -- a-addr )
        SP.push(LeaveLink);
    END


    PRIMARY -noheader $set_leave_link                   ( a-addr -- )
        LeaveLink = SP.pop();
    END


    PRIMARY -noheader $save_leave_link                  ( -- )
        // save the leave link and initialize fresh
        SP.push(LeaveLink);
        LeaveLink = 0;
    END


    SECONDARY -noheader $new_leave_link
        here
        $get_leave_link $comma
        $set_leave_link
    END


    PRIMARY -noheader $restore_leave_link
        // restore the stacked leave link
        LeaveLink = SP.pop();
    END


    SECONDARY -noheader $patch_leave_link
        $get_leave_link $question_dup jmpz(L1)
        dup $fetch $set_leave_link              // get the cell at the fixup address

        then                // prepare the offset and stuff it into place

        1 jmp(L0)

      L1:
        0

      L0:
    END  -- $patch_leave_link


    SECONDARY -noheader $loop_comma
        // store the thread for the loop operator du jour
        $comma

        // deal with the back-jump fixup
        // TOS has target address
        here $sub 1 cells $div $comma

        // patch the leave-list offsets
      L1:
        $patch_leave_link jmpz(L0)
        jmp(L1)

      L0:
        $restore_leave_link
    END -- $loop_comma


    ANSI SECONDARY -immediate do                        ( UNDEF / C: -- do-sys / / n1 n2 -- ; R: -- loop-sys )
        $save_leave_link
        adr($$do) $jmp_comma        // record address for back-jump
    END


    ANSI SECONDARY -immediate $question_do "?do"        ( UNDEF / C: -- do-sys / / n1 n2 -- ; R: --  | loop-sys )
        $save_leave_link
        adr($$question_do) $comma
        $new_leave_link
        here                // record address for back-jump
    END


    ANSI SECONDARY -immediate loop                      ( UNDEF / C: do-sys -- / / -- ; R: loop-sys1 --  | loop-sys2 )
        adr($$loop) $loop_comma
    END


    ANSI SECONDARY -immediate $_add_loop "+loop"        ( UNDEF / C: do-sys -- / / n -- ; R: loop-sys1 --  | loop-sys2 )
        adr($$_add_loop) $loop_comma
    END


    ANSI SECONDARY -immediate unloop                    ( UNDEF / / / -- ; R: loop-sys -- )
        adr($$unloop) $comma
    END


    ANSI SECONDARY -immediate leave                     ( UNDEF / / / -- ; R: loop-sys -- )
        adr($$leave) $comma
        $new_leave_link
    END


    ANSI SECONDARY -immediate case
        0
    END


    ANSI SECONDARY -immediate of
        $1plus
        $to_r
        adr(over) $comma
        adr($eq) $comma
        if
        adr(drop) $comma
        $r_from
    END


    ANSI SECONDARY -immediate endof
        $to_r
        else
        $r_from
    END


    ANSI SECONDARY -immediate endcase
        adr(drop) $comma
        $question_dup jmpz(L2)
        0 $$do
      L1:
            then
        loop(L1)
      L2:
    END


    ANSI SECONDARY -immediate literal                   ( UNDEF / x -- / / -- x )
        adr($$literal) $comma
        $comma
    END


    ANSI SECONDARY -immediate 2literal                  ( UNDEF / dx -- / / -- dx )
        adr($$2literal) $comma
        $2comma
    END


    ANSI SECONDARY -immediate fliteral                  ( UNDEF / F: r -- / / F: -- r )
        adr($$fliteral) $comma
        $fcomma
    END


    ANSI PRIMARY -immediate sliteral                    ( UNDEF / c-addr u / / -- c-addr u )
        slTmp = SP.pop();
        cpTmp = SP.cpPop();

        *DP++ = Cell(CODE_ADDRESS($$sliteral));
        *DP++ = slTmp;
        cpTmp2 = CharPtr(DP);

        DP = CellPtr(CharPtr(DP) + (slTmp + sizeof(Cell) - 1) / sizeof(Cell) * sizeof(Cell));

        // copy the string into dictionary space and round up DP to next cell size
        while(slTmp-- > 0)
            *cpTmp2++ = *cpTmp++;
    END


    ANSI SECONDARY -immediate postpone                  ( UNDEF / "<spaces>name" -- / / )
        bl $$token $search jmpnz(L1)
        $$fail
      L1:
        $immediate $cfetch jmpz(L2)
        // if was immediate word, store it
        $comma
        $immediate c0set
        jmp(L0)

      L2:
        // store code to store the frikker
        adr($$literal) $comma $comma
        adr($comma) $comma
      L0:
    END


    ANSI SECONDARY -immediate recurse                   ( UNDEF / -- / /  )
        entry $to_code $comma
    END


    ANSI SECONDARY -immediate $bracket_char "[char]"    ( UNDEF / "<spaces>name" -- / / -- char )
        bl $$token
        here $cell_plus $cfetch
        adr($$literal) $comma
        $comma
    END


    ANSI SECONDARY -immediate $bracket_tick "[']"       ( UNDEF / "<spaces>name" -- / / -- xt )
        bl $$token $search jmpnz(L1)
        $$fail
      L1:
        adr($$literal) $comma
        $comma
    END



    SECONDARY -noheader $enclose_string
        $$token

        here $fetch $cell_plus
        dp $store_add
        align
    END


    PRIMARY -noheader $make_it_csz
        clTmp = (*DP)++;                // first word is the length, and the string follows
        cpTmp = CharPtr(DP + 1);        // and the string starting at the next word
        cpTmp[clTmp] = 0;
    END


    SECONDARY -noheader $enclose_csz
        $$token $make_it_csz

        here $fetch $cell_plus
        dp $store_add
        align
    END


    // TODO: need to make it available in immediate state AND source-reading mode?
    ANSI SECONDARY -immediate $abort_quote "abort\""    ( i*x x1 --  | i*x ; R: j*x --  | j*x )
        adr($$abort_quote) $comma
        '"' $enclose_string
    END


    SECONDARY -noheader $getta_string
        '"' $$token
        $here_to_word_buf       // leaves address of word buf after copying dictionary addend into it
        dup $fetch              // deref the address and fetch the length
        swap $cell_plus swap    // add one to the address and leave stack with c-addr u
    END


    SECONDARY -noheader $getta_csz
        '"' $$token $make_it_csz
        $here_to_word_buf       // leaves address of word buf after copying dictionary addend into it
        $cell_plus              // add one to the address and leave stack with C-addr
    END


    ANSI SECONDARY -immediate $dot_quote ".\""          ( UNDEF / "ccc<quote>" -- / / -- )
        state $cfetch jmpnz(L1)
        $getta_string
        type
        jmp(L0)

      L1:
        adr($$dot_quote) $comma
        '"' $enclose_string
      L0:
    END


    ANSI SECONDARY -immediate $c_quote "c\""            ( UNDEF / "ccc<quote>" -- / / -- c-addr )
        state $cfetch jmpnz(L1)
        $getta_string
        drop
        1 cells $sub
        jmp(L0)

      L1:
        adr($$c_quote) $comma
        '"' $enclose_string
      L0:
    END


    ANSI SECONDARY -immediate $s_quote "s\""            ( UNDEF / "ccc<quote>" -- / / -- c-addr u )
        state $cfetch jmpnz(L1)
        $getta_string
        jmp(L0)

      L1:
        adr($$s_quote) $comma
        '"' $enclose_string
      L0:
    END


    ANSI SECONDARY -immediate $csz_quote "csz\""        ( UNDEF / "ccc<quote>" -- / / -- c-addr )
        state $cfetch jmpnz(L1)
        $getta_csz
        jmp(L0)

      L1:
        adr($$csz_quote) $comma
        '"' $enclose_csz
      L0:
    END


    ANSI SECONDARY -immediate $dot_paren ".("           ( UNDEF / "ccc<paren>" -- / / )     // print comment at compile time
        ')' $$token
        here $cell_plus
        here $fetch
        type
        // now discard by NOT enclosing it
    END


    //////////////////////////////////////////////////////////////////
    PTHREADS_ORDINARY_STATUS: {
        if(slTmp == 0)
            SP.push(TRUE);
        else {
            SP.push(slTmp);
            SP.push(FALSE);
        }
        goto $NEXT;
    }


    SECONDARY -noheader $$thread        // run the word at TOS then let thread terminate
        $execute
        quit
    END  -- $$thread


    PRIMARY thread::create                              ( xn .. x1 xt n -- error FALSE | threadId TRUE )
        // invoke xt in a separate thread, with n parameters
        slTmp = SP.pop();               // number of params
        if(slTmp < 0) slTmp = 0;        // sanity
        ++slTmp;                        // plus 1 for the xt

        setThreadTransfer(slTmp);
        if(! threadTransfer) {
            // TODO: better handling of memory failure?
            SP.push(ENOMEM);
            SP.push(FALSE);
            goto $ABORT;
        }

        // TODO: mask out the unwanted signals - ALL OF THEM???
        slTmp = pthread_create(&thrTmp, NULL, engine_thread, threadTransfer);
        // TODO: restore the the signal mask

        if(slTmp) {    // error
            free(threadTransfer);
            SP.push(slTmp);
            SP.push(FALSE);
        }
        else {
            // new thread will delete threadTranfer after extracting the data
            SP.push(Cell(thrTmp));
            SP.push(TRUE);
        }
    END


    PRIMARY thread::create_detached
        // SEE section 5.2.3
    END


    PRIMARY thread::cancel                              ( thr -- error FALSE | TRUE )
        // see pthread_setcancelstate(3) and pthread_setcanceltype(3)
        slTmp2 = SP.pop();
        slTmp = pthread_cancel(pthread_t(slTmp2));

        goto PTHREADS_ORDINARY_STATUS;
    END


    PRIMARY thread::detach                              ( thr -- error FALSE | TRUE )
        slTmp2 = SP.pop();
        slTmp = pthread_detach(pthread_t(slTmp2));
        goto PTHREADS_ORDINARY_STATUS;
    END


    PRIMARY thread::equal                               ( thr1 thr2 -- TRUE | FALSE )
        slTmp = SP.pop();
        slTmp2 = SP.pop();
        SP.push(pthread_equal(pthread_t(slTmp), pthread_t(slTmp2)) ? TRUE : FALSE);
    END


    PRIMARY thread::exit                                ( x -- THE ENDLESS VOID )
        // return a memory block with all the stack contents
        if(SP.depth())
            if(pthread_getattr_np(pthread_self(), &pthr_attr) != 0
            || pthread_attr_getdetachstate(&pthr_attr, &slTmp) != 0
            || slTmp != PTHREAD_CREATE_JOINABLE)
                SP.clear();
        setThreadTransfer(SP.depth());
        pthread_exit(VoidPtr(threadTransfer));
    END


    PRIMARY thread::join                                ( thr -- error FALSE | PTHREAD_CANCELED FALSE | retval .. TRUE )
        slTmp2 = SP.pop();
        slTmp = pthread_join(pthread_t(slTmp2), (VoidPtr *) &threadTransfer);
        if(slTmp != 0) {
            SP.push(slTmp2);
            SP.push(FALSE);
        }
        else if(threadTransfer == PTHREAD_CANCELED) {
            threadTransfer == NULL;
            SP.push(Cell(PTHREAD_CANCELED));
            SP.push(FALSE);
        }
        else {
            getThreadTransfer();
            SP.push(TRUE);
        }
    END


    PRIMARY thread::self                                ( -- thr )
        SP.push(Cell(pthread_self()));
    END


    PRIMARY thread::yield                               ( -- error FALSE | TRUE )
        slTmp = sched_yield();
        if(slTmp == -1)
            slTmp = errno;
        goto PTHREADS_ORDINARY_STATUS;
    END


    PRIMARY thread::CANCELED                            ( -- PTHREAD_CANCELED )
        SP.push(Cell(PTHREAD_CANCELED));
    END


    // pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER
    // acts like variable, but allocates enough space to store the mutex
    // Generally: ALLOT further words for your data structure after it,
    // then you can get the mutex-addr with <name>, and the address of
    // the data with <name> mutex+
    // OR: just allot a value or variable y'self and follow the convention
    //
    SECONDARY mutex::create                             ( "<spaces>name" -- / / / -- mtx-addr )
        aligned
        create
        literal(sizeof(pthread_mutex_t))
        allot
        // TODO: return address of following data, and then adjust all methods to self-correct back to the mutex?
    END


    PRIMARY $mutex_plus "mutex+"                        ( mtx-addr -- address-of-trailing-allot )
        SP[1] += sizeof(pthread_mutex_t);
    END


    // int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *attr);
    PRIMARY mutex::init
        cpTmp = SP.cpPop();
        slTmp = pthread_mutex_init((pthread_mutex_t *) cpTmp, NULL);        // TODO: use &pthr_mattr
        goto PTHREADS_ORDINARY_STATUS;
    END


    PRIMARY mutex::destroy                              ( mtx-addr -- )
        cpTmp = SP.cpPop();
        slTmp = 0;
        slTmp = pthread_mutex_destroy((pthread_mutex_t *) cpTmp);
        goto PTHREADS_ORDINARY_STATUS;
    END


    PRIMARY mutex::lock                                 ( mtx-addr -- )
        cpTmp = SP.cpPop();
        slTmp = pthread_mutex_lock((pthread_mutex_t *) cpTmp);
        goto PTHREADS_ORDINARY_STATUS;
    END


    PRIMARY mutex::trylock                              ( mtx-addr -- )
        cpTmp = SP.cpPop();
        slTmp = pthread_mutex_trylock((pthread_mutex_t *) cpTmp);
        goto PTHREADS_ORDINARY_STATUS;
    END


    PRIMARY mutex::unlock                               ( mtx-addr -- )
        cpTmp = SP.cpPop();
        slTmp = pthread_mutex_unlock((pthread_mutex_t *) cpTmp);
        goto PTHREADS_ORDINARY_STATUS;
    END


    SECONDARY condvar::create                             ( "<spaces>name" -- / / / -- mtx-addr )
        aligned
        create
        literal(sizeof(pthread_cond_t))
        allot
        // TODO: return address of following data, and then adjust all methods to self-correct back to the cond?
    END


    PRIMARY $condvar_plus "condvar+"                        ( mtx-addr -- address-of-trailing-allot )
        SP[1] += sizeof(pthread_cond_t);
    END


    PRIMARY condvar::init
        cpTmp = SP.cpPop();
        slTmp = pthread_cond_init((pthread_cond_t *) cpTmp, NULL);        // TODO: use &pthr_mattr
        goto PTHREADS_ORDINARY_STATUS;
    END


    PRIMARY condvar::destroy                              ( mtx-addr -- )
        cpTmp = SP.cpPop();
        slTmp = 0;
        slTmp = pthread_cond_destroy((pthread_cond_t *) cpTmp);
        goto PTHREADS_ORDINARY_STATUS;
    END


    PRIMARY condvar::wait
        // int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
    END


    PRIMARY condvar::timedwait
        // int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, struct timespec *expiration);
    END


    //////////////////////////////////////////////////////////////////

    PRIMARY op
        vocpContext = &voc_op;
    END


    PRIMARY thread
        vocpContext = &voc_thread;
    END


    PRIMARY mutex
        vocpContext = &voc_mutex;
    END


    PRIMARY condvar
        vocpContext = &voc_condvar;
    END



$PREP_CORE:
    if(DP == 0) {
        // only assign this stuff if it's the first thread through
        VOCABULARY op;
        VOCABULARY thread;
        VOCABULARY mutex;
        VOCABULARY condvar;
        VOCABULARY root;
        VOCABULARY forth;

        vocpContext = &voc_forth;
        searchOrder[0] = &voc_root;
        searchOrder[1] = &voc_forth;
        nSearchOrder = 2;

        // TODO: inject ONLY as the top word of all dictionaries (except root - don't want a loop!)

        setupCatcher();
        isatty0 = isatty(0) != 0;
        isatty1 = isatty(1) != 0;

        if(! isatty0 || ! isatty1)
            no_ok = true;
        if(isatty1)
            setvbuf(stdout, NULL, _IONBF, 0);
    }
    else {
        // this is a real engine initialization for a thread,
        // so prepare object memory and capture the vocabs
        Allocator::Init();
        Allocator::MakeSpaces();
        OP::StandardClasses();
        OP::StandardObjects();

        // TODO: set initial search order
        vocpCurrent = vocpContext = &voc_forth;
    }

    goto $START;


    // build more vocabularies here same as above
    //////////////////////////////////////////////////////////////////

$START:
    if(DP == 0) {
        ASSIGN_DP;
        return;
    }

    dnDictLock();

    if(! Base) {
        Base = 10;
        WA = CellPtr(no_ok ? MESSAGE_SILENT : MESSAGE_START);
    }
    else
        WA = CellPtr(MESSAGE_RESTART);

$ABORT:
    if(new_thread != -1) {
        localBase = NULL;
        RS.clear();
        SP.clear();
        FP.clear();
        OS.clear();     // NOTE: objects are abandoned; future reclaim will get them
    }                   // TODO: unless we trigger a reclaim now...

    if(! new_thread)
        SP.push(Quitting ? Cell(MESSAGE_SILENT) : Cell(WA));

    State = Immediate = Quitting = 0;
    Blk = 0;
    SourceID = NULL;

    LBofs = LBlen = 0;
    LBsrc = LineBuffer;
    memset(LineBuffer, sizeof(LineBuffer), 0);

    if(new_thread) {
        if(new_thread == -1)
            goto $TERMINATE;
        new_thread = -1;

        getThreadTransfer();
        IP = FIRST_WORD($$thread);
        goto $NEXT;
    }
    else {
        IP = FIRST_WORD($$outer);
        goto $NEXT;
    }

$TERMINATE:
    return;

}   /* _engine */


void *engine_thread(void *arg) {
    threadTransfer = CellPtr(arg);
    _engine(1);
    // TODO: return a memory block with all the stack contents?

    if(SP.depth())
        if(pthread_getattr_np(pthread_self(), &pthr_attr) != 0
        || pthread_attr_getdetachstate(&pthr_attr, &slTmp) != 0
        || slTmp != PTHREAD_CREATE_JOINABLE)
            SP.clear();
    setThreadTransfer(SP.depth());
    return VoidPtr(threadTransfer);
}   /* engine_thread */


Cell engine() {
    // also need to prepare the BlockBuffers
    BlockBuffer::initQueue("filename");
    _engine(0);
    BlockBuffer::destroyQueue();
    Allocator::Destroy();
    return return_code;
}


// call before any engine is initialized
void engine_init(bool no_ok) {
    ::no_ok = no_ok;
    rwlDict.init();
    rwlLB.init();
    _engine(0);           // first pass through _engine() initializes the dictionary-related variables then exits
}   /* engine_init */


__END__


int __fpclassify (double)
int __signbit    (double)
int   finitel    (double)
int   isinfl     (double)
int   isnanl     (double)
int   ilogbl     (double)

long int      lrintl  (double)
long int      lroundl (double)
long long int llrintl (double)
long long int llroundl(double)

f = nanl(const char *tagb);


////////////////////////////////////////////////////////////////////////////////

3.2.1.2 Digit conversion
Numbers shall be represented externally by using characters from the standard
character set.

Conversion between the internal and external forms of a digit shall behave as
follows:

The value in BASE is the radix for number conversion. A digit has a value
ranging from zero to one less than the contents of BASE. The digit with the
value zero corresponds to the character 0. This representation of digits
proceeds through the character set to the decimal value nine corresponding to
the character 9. For digits beginning with the decimal value ten the graphic
characters beginning with the character A are used. This correspondence
continues up to and including the digit with the decimal value thirty-five which
is represented by the character Z. The conversion of digits outside this range
is implementation defined.

See: A.3.2.1.2 Digit conversion


6.1.0030 #                                      ( ud1 -- ud2 )
number-sign

Divide ud1 by the number in BASE giving the quotient ud2 and the remainder n.
(n is the least-significant digit of ud1.) Convert n to external form and add
the resulting character to the beginning of the pictured numeric output string.
An ambiguous condition exists if # executes outside of a <# #> delimited number
conversion.

See: 6.1.0050 #S


6.1.0040 #>                                     ( xd -- c-addr u )
number-sign-greater

Drop xd. Make the pictured numeric output string available as a character string.
c-addr and u specify the resulting character string. A program may replace
characters within the string.

See: 6.1.0030 # , 6.1.0050 #S , 6.1.0490 <#


6.1.0050 #S                                     ( ud1 -- ud2 )
number-sign-s

Convert one digit of ud1 according to the rule for #. Continue conversion until
the quotient is zero. ud2 is zero. An ambiguous condition exists if #S executes
outside of a <# #> delimited number conversion.


6.1.0180 .                                      ( n -- )
dot

Display n in free field format.

See: 3.2.1.2 Digit conversion, 3.2.1.3 Free-field number display.


6.1.0490 <#                                     ( -- )
less-number-sign

Initialize the pictured numeric output conversion process.

See: 6.1.0030 # , 6.1.0040 #> , 6.1.0050 #S


6.1.0570 >NUMBER                                ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
to-number

ud2 is the unsigned result of converting the characters within the string
specified by c-addr1 u1 into digits, using the number in BASE, and adding each
into ud1 after multiplying ud1 by the number in BASE. Conversion continues left-
to-right until a character that is not convertible, including any + or -, is
encountered or the string is entirely converted. c-addr2 is the location of the
first unconverted character or the first character past the end of the string if
the string was entirely converted. u2 is the number of unconverted characters in
the string. An ambiguous condition exists if ud2 overflows during the conversion.

See: 3.2.1.2 Digit conversion


6.1.1670 HOLD                                   ( char -- )

Add char to the beginning of the pictured numeric output string. An ambiguous
condition exists if HOLD executes outside of a <# #> delimited number conversion.


6.1.2210 SIGN                                   ( n -- )

If n is negative, add a minus sign to the beginning of the pictured numeric
output string. An ambiguous condition exists if SIGN executes outside of a <# #>
 delimited number conversion.


6.2.0210 .R                                     ( n1 n2 -- )
dot-r

Display n1 right aligned in a field n2 characters wide. If the number of
characters required to display n1 is greater than n2, all digits are displayed
with no leading spaces in a field as wide as necessary.

See: A.6.2.0210 .R


6.2.2000 PAD                                    ( -- c-addr )

c-addr is the address of a transient region that can be used to hold data for
intermediate processing.

See: 3.3.3.6 Other transient regions, A.6.2.2000 PAD


6.2.2330 U.R                                    ( u n -- )
u-dot-r

Display u right aligned in a field n characters wide. If the number of
characters required to display u is greater than n, all digits are displayed
with no leading spaces in a field as wide as necessary.



////////////////////////////////////////////////////////////////////////////////

3.2.1.2 Digit conversion
Numbers shall be represented externally by using characters from the standard
character set.

Conversion between the internal and external forms of a digit shall behave as
follows:

The value in BASE is the radix for number conversion. A digit has a value
ranging from zero to one less than the contents of BASE. The digit with the
value zero corresponds to the character 0. This representation of digits
proceeds through the character set to the decimal value nine corresponding to
the character 9. For digits beginning with the decimal value ten the graphic
characters beginning with the character A are used. This correspondence
continues up to and including the digit with the decimal value thirty-five which
is represented by the character Z. The conversion of digits outside this range
is implementation defined.

See: A.3.2.1.2 Digit conversion


6.1.0030 #                                      ( ud1 -- ud2 )
number-sign

Divide ud1 by the number in BASE giving the quotient ud2 and the remainder n.
(n is the least-significant digit of ud1.) Convert n to external form and add
the resulting character to the beginning of the pictured numeric output string.
An ambiguous condition exists if # executes outside of a <# #> delimited number
conversion.

See: 6.1.0050 #S


6.1.0040 #>                                     ( xd -- c-addr u )
number-sign-greater

Drop xd. Make the pictured numeric output string available as a character string.
c-addr and u specify the resulting character string. A program may replace
characters within the string.

See: 6.1.0030 # , 6.1.0050 #S , 6.1.0490 <#


6.1.0050 #S                                     ( ud1 -- ud2 )
number-sign-s

Convert one digit of ud1 according to the rule for #. Continue conversion until
the quotient is zero. ud2 is zero. An ambiguous condition exists if #S executes
outside of a <# #> delimited number conversion.


6.1.0180 .                                      ( n -- )
dot

Display n in free field format.

See: 3.2.1.2 Digit conversion, 3.2.1.3 Free-field number display.


6.1.0490 <#                                     ( -- )
less-number-sign

Initialize the pictured numeric output conversion process.

See: 6.1.0030 # , 6.1.0040 #> , 6.1.0050 #S


6.1.0570 >NUMBER                                ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
to-number

ud2 is the unsigned result of converting the characters within the string
specified by c-addr1 u1 into digits, using the number in BASE, and adding each
into ud1 after multiplying ud1 by the number in BASE. Conversion continues left-
to-right until a character that is not convertible, including any + or -, is
encountered or the string is entirely converted. c-addr2 is the location of the
first unconverted character or the first character past the end of the string if
the string was entirely converted. u2 is the number of unconverted characters in
the string. An ambiguous condition exists if ud2 overflows during the conversion.

See: 3.2.1.2 Digit conversion


6.1.1670 HOLD                                   ( char -- )

Add char to the beginning of the pictured numeric output string. An ambiguous
condition exists if HOLD executes outside of a <# #> delimited number conversion.


6.1.2210 SIGN                                   ( n -- )

If n is negative, add a minus sign to the beginning of the pictured numeric
output string. An ambiguous condition exists if SIGN executes outside of a <# #>
 delimited number conversion.


6.2.0210 .R                                     ( n1 n2 -- )
dot-r

Display n1 right aligned in a field n2 characters wide. If the number of
characters required to display n1 is greater than n2, all digits are displayed
with no leading spaces in a field as wide as necessary.

See: A.6.2.0210 .R


6.2.2000 PAD                                    ( -- c-addr )

c-addr is the address of a transient region that can be used to hold data for
intermediate processing.

See: 3.3.3.6 Other transient regions, A.6.2.2000 PAD


6.2.2330 U.R                                    ( u n -- )
u-dot-r

Display u right aligned in a field n characters wide. If the number of
characters required to display u is greater than n, all digits are displayed
with no leading spaces in a field as wide as necessary.


////////////////////////////////////////////////////////////////////////////////

6.1.0030 #                                      ( ud1 -- ud2 )
6.1.0040 #>                                     ( xd -- c-addr u )
6.1.0050 #S                                     ( ud1 -- ud2 )
6.1.0180 .                                      ( n -- )
6.1.0490 <#                                     ( -- )
6.1.0570 >NUMBER                                ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
6.1.1670 HOLD                                   ( char -- )
6.1.2210 SIGN                                   ( n -- )
6.2.0210 .R                                     ( n1 n2 -- )
6.2.2000 PAD                                    ( -- c-addr )
6.2.2330 U.R                                    ( u n -- )



users of block buffers: block buffer load list thru

blk*            ( -- a-addr )           \ address of the block buffer number
block*          ( u -- a-addr )         \ fetch block u and yield it's address. caching and flushing may ensue
buffer*         ( u -- a-addr )         \ fetch block u and yield it's address. caching and flushing may ensue - wierd relationship to block, appears to NOT involve IO so much
evaluate*                               \ affects blk for reading strings?
flush*          ( -- )                  \ save-buffers then unassign all block buffers
load            ( i*x u -- j*x )        \ lots of details
save-buffers*   ( -- )                  \ write all block buffers which are marked as UPDATED
update          ( -- )                  \ mark current block buffer as UPDATED

empty-buffers*  ( -- )                  \ unassign all block buffers without flushing
list*           ( u -- )
refill          ( -- flag )
scr             ( -- a-addr )
thru            ( i*x u1 u2 .. j*x )    \ LOAD blocks u1..u2 in order
\                                       \ extended behaviour

